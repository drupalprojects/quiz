<?php

// $Id$

/**
 * @file
 * Quiz Module
 *
 * This module allows the creation of interactive quizzes for site visitors.
 */

// This module is structured as follows:
//
// The main module file:
// * Defines and general includes are at the top.
// * Hook implementations come immediately after.
// * Public functions come next.
// * Private functions are at the bottom.
//
// Where possible, user pages are located in quiz.pages.inc, and admin pages
// are in quiz.admin.inc. Most utility functions have been left here, even if they
// are only used by a function in one of the other files. quiz_datetime.inc holds
// some additional date/time functions.
//
// Themes are in quiz.pages.inc unless they clearly only apply to admin screens.
// Then they are in quiz.admin.inc.
//
// Views support is included in includes/views/quiz.views.inc
define('QUIZ_VIEWS_DIR', drupal_get_path('module', 'quiz') . '/includes/views');

module_load_include('inc', 'quiz', 'quiz_datetime');

/*
 * Define question statuses...
 */
define('QUESTION_RANDOM', 0);
define('QUESTION_ALWAYS', 1);
define('QUESTION_NEVER', 2);

/**
 * Quiz name.
 */
define('QUIZ_NAME', _quiz_get_quiz_name());

/**
 * Define feedback statuses.
 */
define('QUIZ_FEEDBACK_END',             0);
define('QUIZ_FEEDBACK_QUESTION',        1);
define('QUIZ_FEEDBACK_NEVER',           2);

/**
 * Define options for keeping results.
 */
define('QUIZ_KEEP_BEST',             0);
define('QUIZ_KEEP_LATEST',        1);
define('QUIZ_KEEP_ALL',           2);

/**
 * Quiz perms.
 *
 * TODO: Simply adding the new quiz config perm for now - refactor other perms
 * to constants in the future.
 */
define('QUIZ_PERM_ADMIN_CONFIG', 'administer quiz configuration');

/**
 * Implementation of hook_help().
 */
function quiz_help($path, $arg) {
  // This is moved on an experimental basis.
  include_once drupal_get_path('module', 'quiz') . '/quiz.help.inc';
  return _quiz_help($path, $arg);
}

/**
 * This module is Views 2.0 enabled.
 * Implementation of hook_views_api().
 */
function quiz_views_api() {
  return array(
    'api' => 2,
    'path' => QUIZ_VIEWS_DIR,
  );
}

/**
 * Implementation of hook_perm().
 */
function quiz_perm() {
  return array(
    // Configure quiz:  
    QUIZ_PERM_ADMIN_CONFIG,
    // Managing quizzes:
    'access quiz', 'create quiz', 'edit own quiz', 'edit any quiz', 'delete any quiz', 'delete own quiz',
    // viewing results:
    'view any quiz results', 'view own quiz results', 'view results for own quiz', 
    // deleting results:
    'delete any quiz results', 'delete results for own quiz',
    // scoring:
    'score any quiz', 'score own quiz',
    // Allow a quiz question to be viewed outside of a test.
    'view quiz question outside of a quiz',
    // Allow the user to see the correct answer, when viewed outside a quiz
    'view any quiz question correct response',
    // Allows users to pick a name for their questions. Otherwise this is auto generated.
    'allow user titles',
    // Allow users to assign an action to be performed when a user has completed a quiz:
    'assign any action to quiz events',
    // Control revisioning, only assign this permission to users who understand who permissions work.
    // REMEMBER: If a quiz or question is changed and not revisioned you will also change existing result reports!
    'manual quiz revisioning',
  );
}

/**
 * Implementation of hook_access().
 */
function quiz_access($op, $node, $account) {
  if (!user_access('access quiz')) {
    // If you can't access, you get NOTHING!
    // Otherwise, we allow further permission checking.
    return FALSE;
  }

  switch ($op) {
    case 'create':
      return user_access('create quiz', $account);
    case 'update':
      return (user_access('edit any quiz', $account)  || (user_access('edit own quiz', $account) && $account->uid == $node->uid));
    case 'delete':
      return (user_access('delete any quiz', $account)  || (user_access('delete own quiz', $account) && $account->uid == $node->uid));
  }
}

/**
 * Helper function to determine if a user has access to the different results pages.
 *
 * @param $node
 * @param $account
 * @return boolean
 *   true if user has permission
 */
function quiz_access_results($quiz, $rid = NULL) {
  global $user;
  if (isset($rid)) {
    $sql = 'SELECT qnr.nid
            FROM {quiz_node_results} qnr
            WHERE result_id = %d';
    $res = db_result(db_query($sql, $rid));
    if ($res != $quiz->nid) return FALSE;
  }
  if (user_access('view any quiz results')) {
    return TRUE;
  }
  if (user_access('view results for own quiz') && $user->uid == $quiz->uid)
    return TRUE;
}

/**
 * Helper function to determine if a user has access to score a quiz.
 *
 * @param $quiz_creator
 *   uid of the quiz creator
 */
function quiz_access_to_score($quiz_creator = NULL) {
  global $user;
  if ($quiz_creator == NULL) {
    $quiz = quiz_get_quiz_from_menu();
    $quiz_creator = $quiz->uid;
  }
  if (user_access('score any quiz')) {
    return TRUE;
  }
  if (user_access('score own quiz') && $user->uid == $quiz_creator)
    return TRUE;
}

/**
 * Helper function to determine if a user has access to delete a certain result...
 *
 * @param $rid
 *   Result id
 * @return boolean
 *   true if user has permission
 */
function quiz_access_delete_results($rid) {
  global $user;
  if (user_access('delete any quiz results')) {
    return TRUE;
  }
  if (user_access('delete results for own quiz')) {
    $sql = 'SELECT n.uid
            FROM {node} n
            WHERE n.nid = (
              SELECT nid
              FROM {quiz_node_results}
              WHERE result_id = %d
            )';
    return db_result(db_query($sql, $rid)) == $user->uid;
  }
}

function quiz_access_multi_or() {
  $perms = func_get_args();
  foreach ($perms as $perm) 
    if (user_access($perm))
      return TRUE;
}

/**
 * Implementation of hook_node_info().
 */
function quiz_node_info() {
  return array(
    'quiz' => array(
      'name' => t('@quiz', array("@quiz" => QUIZ_NAME)),
      'module' => 'quiz',
      'description' => 'Create interactive quizzes for site visitors',
    )
  );
}

/**
 * Implementation of hook_init().
 *
 * Add quiz-specific styling.
 */
function quiz_init() {
  // MPB FIXME: Probably don't want to add this to _every_ page.
  drupal_add_css(drupal_get_path('module', 'quiz') .'/quiz.css', 'module', 'all');
}

/**
 * Implementation of hook_menu().
 */
function quiz_menu() {
  
  // Take //
  $items['node/%node/take'] = array(
    'title' => t('Take'),
    'page callback' => 'quiz_take',
    'page arguments' => array(1),
    'access callback' => 'quiz_type_confirm',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  
  // ADMIN //
  $items['admin/quiz'] = array(
    'title' => t('@quiz management', array('@quiz' => QUIZ_NAME)),
    'description' => t('View @quiz results, score tests, run reports.', array('@quiz' => QUIZ_NAME)),
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array(QUIZ_PERM_ADMIN_CONFIG, 'score any quiz', 'score own quiz', 'view any quiz results', 'view results for own quiz'),
    'access callback' => 'quiz_access_multi_or',
    'type' => MENU_NORMAL_ITEM, // MENU_CALLBACK, MENU_SUGGESTED_ITEM, MENU_LOCAL_TASK, MENU_DEFAULT_LOCAL_TASK
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    //'weight' => -1,
    //'position' => 'right',
    //'menu_name' => 'name of menu',
  );

  $items['admin/quiz/settings'] = array(
    'title' => t('@quiz settings', array('@quiz' => QUIZ_NAME)),
    'description' => t('Change @quiz settings.', array('@quiz' => QUIZ_NAME)),
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array(QUIZ_PERM_ADMIN_CONFIG),
    'type' => MENU_NORMAL_ITEM, // MENU_CALLBACK, MENU_SUGGESTED_ITEM, MENU_LOCAL_TASK, MENU_DEFAULT_LOCAL_TASK
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  
  $items['admin/quiz/settings/config'] = array(
    'title' => t('@quiz configuration', array('@quiz' => QUIZ_NAME)),
    'description' => t('Configure @quiz options.', array('@quiz' => QUIZ_NAME)),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quiz_admin_settings'),
    'access arguments' => array(QUIZ_PERM_ADMIN_CONFIG),
    'type' => MENU_NORMAL_ITEM, // optional
    'file' => 'quiz.admin.inc',
  );
  
  $items['admin/quiz/settings/quiz_form'] = array(
    'title' => t('@quiz node-form configuration', array('@quiz' => QUIZ_NAME)),
    'description' => t('Configure @quiz node-form default values.', array('@quiz' => QUIZ_NAME)),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quiz_admin_node_form'),
    'access arguments' => array(QUIZ_PERM_ADMIN_CONFIG),
    'type' => MENU_NORMAL_ITEM, // optional
    'file' => 'quiz.admin.inc',
  );

  $items['admin/quiz/reports'] = array(
    'title' => t('@quiz reports and scoring', array('@quiz' => QUIZ_NAME)),
    'description' => t('View @quiz reports.', array('@quiz' => QUIZ_NAME)),
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('view any quiz results', 'view results for own quiz'),
    'access callback' => 'quiz_access_multi_or',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['admin/quiz/reports/results'] = array(
    'title' => t('@quiz results', array('@quiz' => QUIZ_NAME)),
    'description' => 'View results.',
    'page callback' => 'quiz_admin_quizzes',
    'access arguments' => array('view any quiz results', 'view results for own quiz'),
    'access callback' => 'quiz_access_multi_or',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'quiz.admin.inc',
  );
  
  $items['admin/quiz/reports/results/%quiz_type_access'] = array(
    'title' => t('Results for @quiz', array('@quiz' => QUIZ_NAME)),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quiz_results_manage_results_form', 4),
    'access arguments' => array(4),
    'access callback' => 'quiz_access_results',
    'type' => MENU_CALLBACK,
    'file' => 'quiz.admin.inc',
  );
  
  $items['admin/quiz/reports/results/%quiz_type_access/%'] = array(
    'title' => t('View @quiz', array('@quiz' => QUIZ_NAME)),
    'description' => t('View results for the given quiz.'),
    'page callback' => 'quiz_admin_results',
    'page arguments' => array(4, 5),
    'type' => MENU_NORMAL_ITEM, // MENU_CALLBACK, MENU_SUGGESTED_ITEM, MENU_LOCAL_TASK, MENU_DEFAULT_LOCAL_TASK
    'file' => 'quiz.admin.inc',
    'access arguments' => array(4, 5),
    'access callback' => 'quiz_access_results',
  );

  $items['admin/quiz/%/delete'] = array(
    'title' => t('Delete @quiz', array('@quiz' => QUIZ_NAME)),
    'page callback' => 'quiz_admin_result_delete',
    'access arguments' => array(2),
    'access callback' => 'quiz_access_delete_results',
    'type' => MENU_CALLBACK,
    'file' => 'quiz.admin.inc',
  );

  // JSON callback
  $items['admin/quiz/listquestions'] = array(
    'title' => t('List Quiz Questions'),
    'description' => t('Auto-completion question listing.'),
    'page callback' => 'quiz_admin_list_questions_ac',
    'page arguments' => array(''),
    'type' => MENU_CALLBACK,
    //'access callback' => 'user_access',
    'access arguments' => array('create quiz'),
    'file' => 'quiz.admin.inc'
  );

  // Menu item for adding questions to quiz.
  $items['node/%node/questions'] = array(
    'title' => t('Manage questions'),
    'page callback' => 'quiz_questions',
    'page arguments' => array(1),
    'access callback' => 'quiz_type_confirm',
    'access arguments' => array(1, 'update'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'quiz.admin.inc',
  );

  // USER //
  $items['user/%/myresults'] = array(
    'title' => t('My results'),
    'page callback' => 'quiz_get_user_results',
    'page arguments' => array(1),
    'access callback' => '_quiz_user_results_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'quiz.pages.inc',
  );

  $items['user/quiz/%/userresults'] = array(
    'title' => t('User results'),
    'page callback' => 'quiz_user_results',
    'page arguments' => array(2),
    'access arguments' => array('view own quiz results'),
    'type' => MENU_CALLBACK,
    'file' => 'quiz.pages.inc',
  );

  $items['admin/quiz/browser/ahah'] = array( //TODO: Add node access instead of user access...
    'title' => t('Filter browser content'),
    'description' => t('AHAH Callback for filtering browser content'),
    'page callback' => 'quiz_browser_ahah',
    'type' => MENU_CALLBACK,
    'access arguments' => array('create quiz'),
    'file' => 'quiz.admin.inc',
  );
  
  $items['admin/quiz/reports/results/browser_ahah'] = array( //TODO: Add node access instead of user access...
    'title' => t('Filter browser content'),
    'description' => t('AHAH Callback for filtering browser content'),
    'page callback' => 'quiz_results_mr_browser_ahah',
    'type' => MENU_CALLBACK,
    'access arguments' => array('create quiz'),
    'file' => 'quiz.admin.inc',
  );

  return $items;
}

/**
 * Implementation of hook_theme().
 */
function quiz_theme() {
  return array(
    'quiz_availability' => array(
      'arguments' => array('node' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_view_stats' => array(
      'arguments' => array('node' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_get_user_results' => array(
      'arguments' => array('results' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_question_table' => array(
      'arguments' => array('questions' => NULL, 'quiz_id' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_filtered_questions' => array(
      'arguments' => array('form' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_take_question' => array(
      'arguments' => array('quiz' => NULL, 'question_node' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_take_summary' => array(
      'arguments' => array('quiz' => NULL, 'questions' => NULL, 'score' => 0, 'summary' => ''),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_admin_summary' => array(
      'arguments' => array('quiz' => NULL, 'questions' => NULL, 'score' => NULL, 'summary' => NULL),
      'file' => 'quiz.admin.inc',
    ),
    'quiz_user_summary' => array(
      'arguments' => array('quiz' => NULL, 'questions' => NULL, 'score' => NULL, 'summary' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_single_question_feedback' => array(
      'arguments' => array('quiz' => NULL, 'report' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_questions' => array(
        'arguments' => array('form' => NULL),
        'file' => 'quiz.pages.inc',
    ),
    'quiz_progress' => array(
      'arguments' => array('question_number' => NULL, 'num_of_question' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_question_table' => array(
      'arguments' => array('questions' => NULL, 'quiz_id' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_no_feedback' => array(
      'file' => 'quiz.pages.inc',
      'arguments' => array(),
    ),
    'quiz_admin_quizzes' => array(
      'file' => 'quiz.admin.inc',
      'arguments' => array('results' => NULL),
    ),
    'quiz_single_question_node' => array(
      'file' => 'quiz.pages.inc',
      'arguments' => array('question_node' => NULL),
    ),
    'question_selection_table' => array(
      'file' => 'quiz.admin.inc',
      'arguments' => array('form' => array()),
    ),
    'quiz_score_correct' => array(
      'file' => 'quiz.pages.inc',
      'arguments' => array(),
    ),
    'quiz_score_incorrect' => array(
      'file' => 'quiz.pages.inc',
      'arguments' => array(),
    ),
    'quiz_question_browser' => array(
      'arguments' => array(
        'form' => NULL,
      ),
      'path' => drupal_get_path('module', 'quiz') .'/theme',
      'template' => 'quiz_question_browser',
    ),
    'quiz_results_browser' => array(
      'arguments' => array(
        'form' => NULL,
      ),
      'path' => drupal_get_path('module', 'quiz') .'/theme',
      'template' => 'quiz_results_browser',
    ),
    'quiz_report_form' => array(
      'arguments' => array(
        'form' => NULL,
      ),
      'path' => drupal_get_path('module', 'quiz') .'/theme',
      'template' => 'quiz_report_form',
    ),
  );
}

/**
 * Implementation of hook_form_alter().
 *
 * Override settings in some existing forms. For example, we remove the
 * preview button on a quiz.
 */
function quiz_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['#quiz_check_revision_access'])) {
    if (!user_access('manual quiz revisioning')) {
      $form['revision_information']['revision']['#type'] = 'value';
      $form['revision_information']['revision']['#value'] = $form['revision_information']['revision']['#default_value'];
      $form['revision_information']['log']['#type'] = 'value';
      $form['revision_information']['log']['#value'] = $form['revision_information']['log']['#default_value'];
      unset($form['revision_information']['#type'], $form['revision_information']['#title'], $form['revision_information']['#description']);
    }
    unset($form['buttons']['preview']);
    if ($form['#cancel_button']) {
      $form['buttons']['cancel'] = array(
          '#type' => 'markup',
          '#value' => l(t('Cancel'), $form['#redirect']),
          '#weight' => 6,
        );
    }
  }
}

/**
 * Implementation of hook_insert().
 */
function quiz_insert($node) {
  _quiz_save_user_settings($node);
  if ($node->is_new && isset($node->translation_source))
    quiz_copy_questions($node);
  _quiz_common_presave_actions($node);

  $tid = (isset($node->tid) ? $node->tid : 0);

  if (!isset($node->has_userpoints)) {
    $node->has_userporints = 0;
  }

  $sql = "INSERT INTO {quiz_node_properties}
    (vid, nid, aid, number_of_random_questions, randomization,
      backwards_navigation, repeat_until_correct, quiz_open, quiz_close, takes, keep_results, time_limit, pass_rate, summary_pass, summary_default, quiz_always, feedback_time, tid, has_userpoints, allow_skipping)
    VALUES(%d, %d, '%s', %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, '%s', '%s', %d, %d, %d, %d, %d)";
  _quiz_check_num_random($node);
  db_query($sql, $node->vid, $node->nid, $node->aid, $node->number_of_random_questions, $node->randomization, $node->backwards_navigation, $node->repeat_until_correct, $node->quiz_open, $node->quiz_close, $node->takes, $node->keep_results, $node->time_limit, $node->pass_rate, $node->summary_pass, $node->summary_default, $node->quiz_always, $node->feedback_time, $node->has_userpoints, $tid, $node->allow_skipping);
  _quiz_insert_resultoptions($node);
  if (!$node->auto_created && $node->revision == 0) {
    drupal_set_message("You just created a new quiz. Now you have to add questions to it. This page is for adding and managing questions. Here you can create new questions or add some of your already created questions. If you want to change the quiz settings, you can use the \"edit\" tab.");
    $_REQUEST['destination'] = url("node/$node->nid/questions");
  }
  if (!$node->auto_created)
    _quiz_redirect_if_empty($node);
}

/**
 * Implementation of hook_update().
 */
function quiz_update($node) {
  _quiz_save_user_settings($node);
  // Quiz node vid (revision) was updated.
  if ($node->revision) {

    // Insert a new row in the quiz_node_properties table.
    $old_auto = $node->auto_created;
    $node->auto_created = TRUE;
    quiz_insert($node);
    $node->auto_created = $old_auto;

    // Create new quiz-question relation entries in the quiz_node_relationship table.
    quiz_update_quiz_question_relationship($node->old_vid, $node->vid, $node->nid);
  }

  // Quiz node vid (revision) was not updated.
  else {
    // Update an existing row in the quiz_node_properties table.
    _quiz_common_presave_actions($node);
    $sql = "UPDATE {quiz_node_properties}
      SET vid = %d,
        aid='%s',
        randomization = %d,
        backwards_navigation = %d,
        repeat_until_correct = %d,
        quiz_open = %d,
        quiz_close = %d,
        takes = %d,
        keep_results = %d,
        time_limit = '%d',
        pass_rate = %d,
        summary_pass = '%s',
        summary_default = '%s',
        quiz_always = %d,
        feedback_time = %d,
        number_of_random_questions = %d,
        has_userpoints = %d,
        allow_skipping = %d
      WHERE vid = %d
        AND nid = %d";
    _quiz_check_num_random($node);
    $resource = db_query($sql, $node->vid, $node->aid, $node->randomization, $node->backwards_navigation, $node->repeat_until_correct, $node->quiz_open, $node->quiz_close,
      $node->takes, $node->keep_results, $node->time_limit, $node->pass_rate, $node->summary_pass, $node->summary_default, $node->quiz_always,
      $node->feedback_time, $node->number_of_random_questions, $node->has_userpoints, $node->allow_skipping,
      $node->vid, $node->nid);
    _quiz_update_resultoptions($node);
    // if (db_affected_rows($resource) == 0) {
    //       drupal_set_message('No quiz was found that could be modified.', 'status');
    //     }
  }
  _quiz_redirect_if_empty($node);
}

function _quiz_common_presave_actions(&$node) {
  quiz_translate_form_date($node, 'quiz_open');
  quiz_translate_form_date($node, 'quiz_close');
  if (empty($node->pass_rate)) $node->pass_rate = 0;
}

/**
 * Implementation of hook_delete().
 */
function quiz_delete($node) {
  // This first line should load all the vid's for the nid.
  db_query('DELETE FROM {quiz_node_properties} WHERE vid = %d AND nid = %d', $node->vid, $node->nid);
  db_query('DELETE FROM {quiz_node_relationship} WHERE parent_nid = %d', $node->nid);
  db_query('DELETE FROM {quiz_node_results} WHERE vid = %d AND nid = %d', $node->vid, $node->nid);
  db_query('DELETE FROM {quiz_node_result_options} WHERE vid = %d AND nid = %d', $node->vid, $node->nid);
}

function _quiz_get_node_defaults() {
  return array(
    'property_id' => NULL,
    'aid' => NULL,
    'number_of_random_questions' => 0,
    'pass_rate' => 75,
    'summary_pass' => '',
    'summary_default' => '',
    'randomization' => 0,
    'backwards_navigation' => 1,
    'repeat_until_correct' => 0,
    'feedback_time' => 0,
    'quiz_open' => 0,
    'quiz_close' => 0,
    'takes' => 1,
    'keep_results' => 0,
    'time_limit' => 0,
    'quiz_always' => 1,
    'tid' => 0,
    'has_userpoints' => 0,
    'allow_skipping' => 1,
  );
}

/**
 * Implementation of hook_load().
 */
function quiz_load($node) {
  $default_additions = _quiz_get_node_defaults();
  $fields = implode(', ', array_keys($default_additions));

  $quiz_vid  = $node->vid;
  $sql = 'SELECT %s FROM {quiz_node_properties} WHERE vid = %d AND nid = %d ORDER BY property_id DESC';
  $fetched_additions = db_fetch_array(db_query($sql, $fields, $quiz_vid, $node->nid));

  $additions = ($fetched_additions) ? (object)($fetched_additions += $default_additions) : NULL;
  /*
   * This doesn't appear to have ever worked.... It just adds an empty item to $additions->status.
   * Also, I can't find where this information is ever used, so there's probably no point in fixing it.
  $results   = db_query('SELECT nr.nid, qnr.question_status, qnr.child_nid
    FROM {quiz_node_relationship} qnr
    INNER JOIN {node_revisions} nr ON (qnr.parent_vid = nr.vid AND qnr.parent_nid = nr.nid)
    WHERE qnr.parent_vid = %d AND qnr.parent_nid = %d', $quiz_vid, $node->nid);

  while ($question = db_fetch_object($results)) {
    $additions->question_status[$question->child_nid] = $question->status;
    $additions->status[$question->child_nid] = $question->status;

  }*/

  $result_options = db_query('SELECT * FROM {quiz_node_result_options} WHERE nid = %d AND vid= %d', $node->nid, $node->vid);
  while ($option = db_fetch_array($result_options)) {
    $additions->resultoptions[$option['option_id']] = $option;
  }
  return $additions;
}

/**
 * Implementation of hook_view().
 */
function quiz_view($node, $teaser = FALSE, $page = FALSE) {
  drupal_alter('quiz_view', $node, $teaser, $page);
  $node = node_prepare($node, $teaser);
  $node->number_of_questions = $node->number_of_random_questions + _quiz_get_num_always_questions($node->nid, $node->vid);
    $node->content['stats'] = array(
      '#value' => theme('quiz_view_stats', $node),
      '#weight' => -1,
    );
  if (!$teaser) {
    $node->content['take'] = array(
      '#value' => drupal_get_form('quiz_start_quiz_button_form', $node),
      '#weight' => 2,
    );
  }
  else {
    $node->content['take'] = array(
      '#value' => '<p>'. l(t('Start quiz'), 'node/'. $node->nid .'/take') .'</p>',
      '#weight' => 2,
    );
  }
  
  return $node;
}

function quiz_start_quiz_button_form(&$form_state, $node) {
  $form = array();
  $form['#action'] = url("node/$node->nid/take");
  $form['button'] = array(
    '#type' => 'button',
    '#value' => t('Start quiz'),
  );
  return $form;
}

/**
 * Primary quiz-taking view (on Take tab)
 */
function quiz_take($node) {
  drupal_alter('quiz_take', $node);
  // load the questions in the view page
  return drupal_render(quiz_take_quiz($node));
}  

// QUIZ FORM

/**
 * Implementation of hook_form().
 *
 * This is an admin form used to build a new quiz. It is called as part of the node edit form.
 */
function quiz_form(&$node) {
  $form = array();
  if (!isset($node->nid)) {
    $settings_loaded = _quiz_load_user_settings($node);
    if (!$settings_loaded) {
      drupal_set_message(t('You are making your first @quiz. On this page you set the attributes, most of which will be remembered for the future. On the next screen you can add questions.',
                         array('@quiz' => QUIZ_NAME) ));
      $node->def_uid = variable_get('quiz_def_uid', 1);
      _quiz_load_user_settings($node);
    }
  }
  
  $form['#quiz_check_revision_access'] = TRUE;
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#default_value' => $node->title,
    '#description' => t('The name of the @quiz.', array('@quiz' => QUIZ_NAME)),
    '#required' => TRUE,
  );
  
  $form['body_field']['body'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $node->body,
    '#description' => t('A description of what the @quiz entails', array('@quiz' => QUIZ_NAME)),
    '#required' => FALSE,
    );
  $form['body_field']['format'] = filter_form($node->format);
  
  $form['taking'] = array(
    '#type' => 'fieldset',
    '#title' => t('Taking options'),
    '#collapsed' => $settings_loaded,
    '#collapsible' => TRUE,
  );
  $form['taking']['allow_skipping'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow Skipping questions'),
    '#default_value' => isset($node->allow_skipping) ? $node->allow_skipping : 1,
    '#description' => t('Whether to allow users to skip questions on the @quiz', array('@quiz' => QUIZ_NAME)),
  );
  
  $form['taking']['backwards_navigation'] = array(
    '#type' => 'checkbox',
    '#title' => t('Backwards navigation'),
    '#default_value' => isset($node->backwards_navigation) ? $node->backwards_navigation : 1,
    '#description' => t('Whether to allow user to go back and revisit their answers'),
  );

  $form['taking']['repeat_until_correct'] = array(
    '#type' => 'checkbox',
    '#title' => t('Repeat until correct'),
    '#default_value' => $node->repeat_until_correct,
    '#description' => t('Require the user to re-try the question until they answer it correctly.'),
  );
  
  $form['taking']['randomization'] = array(
    '#type' => 'radios',
    '#title' => t('Randomize questions'),
    '#options' => array(
      t('No randomization'),
      t('Random order'),
      t('Random questions'),
    ),
    '#description' => t('The difference between "random order" and "random questions" is that with "random questions" questions are drawn randomly from a pool of questions. With "random order" the quiz will always consist of the same questions.'),
    '#default_value' => isset($node->randomization) ? $node->randomization : 0,
  );

  $form['taking']['feedback_time'] = array(
    '#title' => t('Feedback Time'),
    '#type' => 'radios',
    '#default_value' => (isset($node->feedback_time) ? $node->feedback_time : QUIZ_FEEDBACK_END),
    '#options' => _quiz_get_feedback_options(),
    '#description' => t('Indicates at what point feedback for each question will be given to the user'),
  );

  /*
   * Added the action as a dropdown for selection with specific quizzes
   * This allows you to choose a defined action from the actions module for use when
   * a user completes the quiz.
   */
  if (user_access('assign any action to quiz events')) {
    $form['taking']['aid'] = array(
      '#title' => t('Assign Action'),
      '#description' => t('Select an action to be preformed after a user has completed this @quiz.', array('@quiz' => QUIZ_NAME)),
      '#type' => 'select',
      /*
       * An idea here would be to add a system conf variable into the quiz_action_options() function that
       * could filter the type of actions you could display on your quizzes.  For Example: you create
       * a custom module that defines some actions that you only want a user to choose when creating
       * a quiz and selecting an action from the dropdown.  You setup your actions with type 'quiz' and
       * then add in that variable into the function and it will automatically filter and show only
       * those specific actions.  @note:  In doing this you loose your default "Choose an Action"
       * option.  Review actions and the quiz_action_options() function for further explaination.
       */
      '#options' => quiz_action_options(variable_get('quiz_action_type', 'all')),
      '#default_value' => MD5($node->aid),
    );
  }
  $options = array(t('Unlimited'));
  for ($i = 1; $i < 10; $i++) {
    $options[$i] = $i;
  }
  $form['taking']['multiple_takes'] = array(
    '#type' => 'fieldset',
    '#title' => t('Multiple takes'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  $form['taking']['multiple_takes']['takes'] = array(
    '#type' => 'select',
    '#title' => t('Number of takes'),
    '#default_value' => isset($node->takes) ? $node->takes : 1,
    '#options' => $options,
    '#description' => t('The number of times a user is allowed to take the @quiz', array('@quiz' => QUIZ_NAME)),
  );
  if (user_access('delete any quiz results') || user_access('delete results for own quiz')) {
    $form['taking']['multiple_takes']['keep_results'] = array(
      '#type' => 'radios',
      '#title' => t('These results should be stored for each user'),
      '#options' => array(
         t('The best'),
         t('The newest'),
         t('All'),
      ),
      '#default_value' => isset($node->keep_results) ? $node->keep_results : QUIZ_KEEP_ALL,
    );
  }
  else {
    $form['taking']['multiple_takes']['keep_results'] = array(
      '#type' => 'value',
      '#value' => isset($node->keep_results) ? $node->keep_results : QUIZ_KEEP_ALL,
    );
  }
  
  if (function_exists('jquery_countdown_add') && variable_get('quiz_has_timer', 0)) {
    $form['taking']['addons'] = array(
      '#type' => 'fieldset',
      '#title' => t('Quiz Addons Properties'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['taking']['addons']['time_limit'] = array(
      '#type' => 'textfield',
      '#title' => t(' Time Limit'),
      '#default_value' => isset($node->time_limit) ? $node->time_limit : 0,
      '#description' => t('Set the maximum allowed time in seconds for this @quiz. Use 0 for no limit.', array('@quiz' => QUIZ_NAME)),
    );
  }
  else {
    $form['taking']['addons']['time_limit'] = array(
      '#type' => 'value',
      '#value' => 0,
    );
  }


  if (module_exists('userpoints') && variable_get('quiz_has_userpoints', 0)) {
    $form['has_userpoints'] = array(
      '#type' => 'checkbox',
      '#default_value' => (isset($node->has_userpoints) ? $node->has_userpoints : 1),
      '#title' => t('Enable UserPoints Module Integration'),
      '#description' => t('If checked, marks scored in this @quiz will be credited to userpoints. For each correct answer 1 point will be added to user\'s point.', array('@quiz' => QUIZ_NAME)),
    );
  }
  // Set up the availability options.
  $form['quiz_availability'] = array(
    '#type' => 'fieldset',
    '#title' => t('Availability options'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
  );
  $form['quiz_availability']['quiz_always'] = array(
    '#type' => 'checkbox',
    '#title' => t('Always Available'),
    '#default_value' => isset($node->quiz_always) ? $node->quiz_always : 1,
    '#description' => t('Click this option to ignore the open and close dates.'),
  );
  $form['quiz_availability']['quiz_open'] = array(
    '#type' => 'date',
    '#title' => t('Open Date'),
    '#default_value' => _quiz_form_prepare_date($node->quiz_open),
    '#description' => t('The date this @quiz will become available.', array('@quiz' => QUIZ_NAME)),
  );
  $form['quiz_availability']['quiz_close'] = array(
    '#type' => 'date',
    '#title' => t('Close Date'),
    '#default_value' => _quiz_form_prepare_date($node->quiz_close, variable_get('quiz_default_close', 30)),
    '#description' => t('The date this @quiz will cease to be available.', array('@quiz' => QUIZ_NAME)),
  );
  // Quiz summary options.
  $form['summaryoptions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Pass/fail options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  // If pass/fail option is checked, present the form elements.
  if (variable_get('quiz_use_passfail', 1)) {
    $form['summaryoptions']['pass_rate'] = array(
      '#type' => 'textfield',
      '#title' => t('Pass rate for @quiz (%)', array('@quiz' => QUIZ_NAME)),
      '#default_value' => $node->pass_rate,
      '#description' => t('Pass rate for the @quiz as a percentage score.', array('@quiz' => QUIZ_NAME)),
      '#required' => FALSE,
    );
    $form['summaryoptions']['summary_pass'] = array(
      '#type' => 'textarea',
      '#title' => t('Summary text if passed'),
      '#default_value' => $node->summary_pass,
      '#cols' => 60,
      '#description' => t("Summary for when the user gets enough correct answers to pass the @quiz. Leave blank if you don't want to give different summary text if they passed or if you are not using the 'percent to pass' option above. If you don't use the 'Percentage needed to pass' field above, this text will not be used.", array('@quiz' => QUIZ_NAME)),
    );
    $form['summaryoptions']['format'] = filter_form($node->format, NULL, array('summary_format'));
  }
  // If the pass/fail option is unchecked, use the default and hide it.
  else {
    $form['summaryoptions']['pass_rate'] = array(
      '#type' => 'hidden',
      '#value' => isset($node->pass_rate) ? $node->pass_rate : 75,
      '#required' => FALSE,
    );
  }
  $form['summaryoptions']['summary_default'] = array(
    '#type' => 'textarea',
    '#title' => t('Default summary text'),
    '#default_value' => $node->summary_default,
    '#cols' => 60,
    '#description' => t("Default summary. Leave blank if you don't want to give a summary."),
  );
  $form['summaryoptions']['def_format'] = filter_form($node->format, NULL, array('default_format'));

  $num_rand = (isset($node->number_of_random_questions)) ? $node->number_of_random_questions : 0;
  $form['number_of_random_questions'] = array(
    '#type' => 'value',
    '#value' => $num_rand,
  );

  $form['resultoptions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Result Comments'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
  );

  $options = !empty($node->resultoptions) ? $node->resultoptions : array();
  $num_options = max(count($options), variable_get('quiz_max_result_options', 5));

  for ($i=0; $i < $num_options; $i++) {
    $option = (count($options) > 0) ? array_shift($options) : NULL; // grab each option in the array
    $form['resultoptions'][$i] = array(
      '#type' => 'fieldset',
      '#title' => t('Result Option ') . ($i + 1),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['resultoptions'][$i]['option_name'] = array(
      '#type' => 'textfield',
      '#title' => t('The name of the result'),
      '#default_value' => $option['option_name'],
      '#maxlength' => 40,
      '#size' => 40,
    );
    $form['resultoptions'][$i]['option_start'] = array(
      '#type' => 'textfield',
      '#title' => t('Percentage Start Range'),
      '#description' => t('Show this result for scored quizzes in this range (0-100).'),
      '#default_value' => $option['option_start'],
      '#size' => 5,
    );
    $form['resultoptions'][$i]['option_end'] = array(
      '#type' => 'textfield',
      '#title' => t('Percentage End Range'),
      '#description' => t('Show this result for scored quizzes in this range (0-100).'),
      '#default_value' => $option['option_end'],
      '#size' => 5,
    );
    $form['resultoptions'][$i]['option_summary'] = array(
      '#type' => 'textarea',
      '#title' => t('Display text for the result'),
      '#default_value' => $option['option_summary'],
      '#description' => t('Result summary. This is the summary that is displayed when the user falls in this result set determined by his/her responses.'),
    );
    $form['resultoptions'][$i]['format'] = filter_form($node->format, NULL, array('resultoptions', $i, 'filter_format'));
    if ($option['option_id']) {
      $form['resultoptions'][$i]['option_id'] = array(
        '#type' => 'hidden',
        '#value' => $option['option_id'],
      );
    }
  }
  if (quiz_has_been_answered($node)) {
    $log = 'The current revision has been answered. We create a new revision so that the reports ';
    $log .= 'from the existing answers stays correct.';
    $node->revision = 1;
    $node->log = t($log);
  }
  return $form;
}

/**
 * Implementation of hook_validate().
 */
function quiz_validate($node) {
  if (!$node->nid && empty($_POST)) return;

  if (mktime(0, 0, 0, $node->quiz_open['month'], $node->quiz_open['day'], $node->quiz_open['year']) > mktime(0, 0, 0, $node->quiz_close['month'], $node->quiz_close['day'], $node->quiz_close['year'])) {
    form_set_error('quiz_close', t('Please make sure the close date is after the open date.'));
  }
  if(!empty($node->pass_rate)) {
    if (!is_numeric($node->pass_rate)) {
      form_set_error('pass_rate', t('The pass rate value must be a number between 0% and 100%.'));
    }
    if ($node->pass_rate > 100) {
      form_set_error('pass_rate', t('The pass rate value must not be more than 100%.'));
    }
    if ($node->pass_rate < 0) {
      form_set_error('pass_rate', t('The pass rate value must not be less than 0%.'));
    }
  }

  if (isset($node->time_limit)) {
    if ($node->time_limit < 0 || !is_numeric($node->time_limit)) {
      form_set_error('time_limit', t('Time limit must be a non negative interger '));
    }
  }

  $taken_values = array();
  $num_options =0;
  foreach ($node->resultoptions as $option) {
    if (!empty($option['option_name'])) {
      $num_options++;
      if (empty($option['option_summary'])) {
        form_set_error('option_summary', t('Option has no summary text.'));
      }
      if ($node->pass_rate && (isset($option['option_start']) || isset($option['option_end']))) {

        // Check for a number between 0-100.
        foreach (array('option_start' => 'start', 'option_end' => 'end') as $bound => $bound_text) {
          if (!is_numeric($option[$bound])) {
            form_set_error($bound, t('The range %start value must be a number between 0% and 100%.', array('%start' => $bound_text)));
          }
          if ($option[$bound] < 0) {
            form_set_error($bound, t('The range %start value must not be less than 0%.', array('%start' => $bound_text)));
          }
          if ($option[$bound] > 100) {
            form_set_error($bound, t('The range %start value must not be more than 100%.', array('%start' => $bound_text)));
          }
        }

        // Check that range end >= start.
        if ($option['option_start'] > $option['option_end']) {
          form_set_error('option_start', t('The start must be less than the end of the range.'));
        }

        // Check that range doesn't collide with any other range.
        $option_range = range($option['option_start'], $option['option_end']);
        if ($intersect = array_intersect($taken_values, $option_range)) {
          form_set_error('option_start', t('The ranges must not overlap each other. (%intersect)', array('%intersect' => implode(',', $intersect))));
        }
        else {
          $taken_values = array_merge($taken_values, $option_range);
        }
      }
    }
    elseif (!empty($option['option_summary'])) {
        form_set_error('option_summary', t('Option has a summary, but no name.'));
    }
  }
}
/**
 * Implementation of hook_nodeapi()
 */
function quiz_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  // We need to filter on node type to prevent this from overriding any other node
  if ($node->type == 'quiz') {
    switch ($op) {
      case 'presave':
        /*
         * convert the action id to the actual id from the MD5 hash
         * Why the actions module does this I do not know?  Maybe to prevent invalid values put
         * into the options value="" field.
         */
        if ($aid = actions_function_lookup($node->aid))
          $node->aid = $aid;
        break;
      case 'prepare':
        // Meet E_STRICT on new nodes.
        $defaults = _quiz_get_node_defaults();
        if (!isset($node->nid)) {
          //drupal_set_message('Building defaults');
          foreach ($defaults as $key => $value) {
            if (!isset($node->$key)) {
              $node->$key = $value;
            }
          }
        }
    }
  }
  /* If we want to pre-process question nodes before they get rendered, here's how to do it:
  if ($op == 'view' && in_array($node->type, array_keys(_quiz_get_question_types())) && $a3) {
    drupal_set_message("Do global munging of node content here.");
    //var_dump($node->content);
  }
  if ($op == 'alter' && in_array($node->type, array_keys(_quiz_get_question_types())) && $a3) {
    drupal_set_message("Do alter of node content here.");
    //var_dump($node->content);
  }
  */
}

/**
 * Implementation of hook user.
 */
function quiz_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'delete':
      $sql = 'DELETE FROM {quiz_user_settings}
              WHERE uid = %d';
      db_query($sql, $account->uid);
    break;
  }
}
// END HOOKS

/**
 * Load a quiz node and validate it.
 *
 * @param $arg
 *  The Node ID
 * @return
 *  A quiz node object or FALSE if a load failed.
 */
function quiz_type_access_load($arg) {
  static $quiz_nodes = array();
  if (isset($quiz_nodes[$arg])) {
    return $quiz_nodes[$arg];
  }
  if (arg(0) == 'node' && is_numeric(arg(1)))
    $already_loaded = menu_get_object(); 
  if (arg(2) == 'take' && isset($_SESSION['quiz_'. $arg]['quiz_vid'])) {
    if ($already_loaded->vid == $_SESSION['quiz_'. $arg]['quiz_vid'])
      $to_return = $already_loaded->type == 'quiz' ? $already_loaded : FALSE;
    else
      $to_return = (($node = node_load($arg, $_SESSION['quiz_'. $arg]['quiz_vid'])) && $node->type == 'quiz') ? $node : FALSE;
  }
  else {
    if ($already_loaded->nid == $arg)
      $to_return = $already_loaded->type == 'quiz' ? $already_loaded : FALSE;
    else 
      $to_return = (($node = node_load($arg)) && $node->type == 'quiz') ? $node : FALSE;
  }
  if ($to_return) {
    $quiz_nodes[$arg] = $to_return;
  }
  return $to_return;
}

function quiz_type_confirm($node, $op = NULL) {
  if ($node->type != 'quiz') return false;
  if (isset($op)) return node_access($op, $node);
  return user_access('access quiz');
}

/**
 * Returns the titles for all quizzes the user has access to.
 *
 * @return quizzes
 *   array with nids as keys and titles as values
 */
function quiz_get_all_titles() {
  $sql = 'SELECT nid, title
          FROM {node} n
          WHERE n.type = \'quiz\'';
  $res = db_query(db_rewrite_sql($sql));
  $to_return = array();
  while ($res_o = db_fetch_object($res)) {
    $to_return[$res_o->nid] = $res_o->title;
  }
  return $to_return;
}

/**
 *
 * @param array $nids
 *   nids for the quizzes we want to collect scores from
 * @param int $uid
 *   uid for the user we want to collect score for.
 * @param boolean $include_num_questions
 *   Do we want to collect information about the number of questions in a quiz?(adds a performance hit)
 * @return array of score data
 */
function quiz_get_score_data($nids, $uid, $include_num_questions = FALSE) {
  foreach ($nids as $key => $nid) {
    if(!is_int($nid)) unset($nids[$key]);
  }
  if (empty($nids)) return array();
  $to_return = array();
  $vids = array();
  $sql = 'SELECT n.title, n.nid, n.vid, p.number_of_random_questions as num_random_questions, r.score AS percent_score, p.max_score, p.summary_pass AS percent_pass
          FROM {node} n
          JOIN {quiz_node_properties} p
          ON n.vid = p.vid
          JOIN {quiz_node_results} r
          ON r.nid = n.nid
          JOIN (
            SELECT nid, max(score) as highest_score
            FROM {quiz_node_results}
            GROUP BY nid
          ) rm
          ON n.nid = rm.nid AND r.score = rm.highest_score
          WHERE n.nid in ('. implode(', ', $nids) .')
          AND r.uid = %d';
  $res = db_query(db_rewrite_sql($sql), $uid);
  while ($res_o = db_fetch_object($res)) {
    if (!$include_num_questions) unset($res_o->num_random_questions);
    $to_return[$res_o->vid] = $res_o;
    $vids[] = $res_o->vid;
  }
  if (empty($vids)) return array();
  if ($include_num_questions) {
    $sql = 'SELECT COUNT(*) as num_always_questions, parent_vid
            FROM {quiz_node_relationship}
            WHERE parent_vid IN ('. implode(', ', $vids) .')
            AND question_status = %d
            GROUP BY parent_vid';
    $res = db_query(db_rewrite_sql($sql), QUESTION_ALWAYS);
    while ($res_o = db_fetch_object($res)) {
      $to_return[$res_o->parent_vid]->num_questions = $to_return[$res_o->parent_vid]->num_random_questions + $res_o->num_always_questions;
    }
  }
  return $to_return;
}

/**
 * Finds out the number of questions for the quiz.
 *
 * Good example of usage could be to calculate the % of score.
 *
 * @param $nid
 *  Quiz ID
 * @return integer
 *  Returns the number of quiz questions.
 */
function quiz_get_number_of_questions($vid, $nid) {
  $always_count = _quiz_get_num_always_questions($nid, $vid);
  $rand_count = db_result(db_query('SELECT number_of_random_questions FROM {quiz_node_properties} WHERE nid = %d AND vid = %d', $nid, $vid));
  return $always_count + (int)$rand_count;
}

/**
 * Finds out the pass rate for the quiz.
 *
 * @param $nid
 *  The quiz ID.
 * @return integer
 *  Returns the passing percentage of the quiz.
 */
function quiz_get_pass_rate($nid, $vid) {
    return db_result(db_query('SELECT pass_rate FROM {quiz_node_properties} WHERE nid = %d AND vid = %d', $nid, $vid));
}

/**
 * Updates quiz-question relation entries in the quiz_node_relationship table.
 *
 * @access public
 * @param integer $old_quiz_vid
 *  The quiz vid prior to a new revision.
 * @param integer $new_quiz_vid
 *  The quiz vid of the latest revision.
 */
function quiz_update_quiz_question_relationship($old_quiz_vid, $new_quiz_vid, $quiz_nid) {
  $sql = "INSERT INTO {quiz_node_relationship} (parent_nid, parent_vid, child_nid, child_vid, question_status, max_score)
    SELECT src.parent_nid, %d, src.child_nid, src.child_vid, src.question_status, src.max_score
    FROM {quiz_node_relationship} AS src
    WHERE src.parent_vid = %d AND src.parent_nid = %d AND src.question_status != %d";
  db_query($sql, $new_quiz_vid, $old_quiz_vid, $quiz_nid, QUESTION_NEVER);
}


/**
 * Handles quiz taking.
 *
 * This gets executed when the main quiz node is first loaded.
 *
 * @param $quiz
 *  The quiz node.
 *
 * @return
 *  Content array
 */
function quiz_take_quiz($quiz) {
  global $user;
  $allow_skipping = $quiz->allow_skipping;

  // If no access, fail.
  if (!user_access('access quiz')) {
    drupal_access_denied();
    return;
  }
  if (!isset($quiz)) {
    drupal_not_found();
    return;
  }

  // If anonymous user and no unique hash, refresh with a unique string to prevent caching.
  if (!$quiz->name && arg(4) == NULL) {
    drupal_goto('node/'. $quiz->nid .'/take/'. md5(mt_rand() . time()));
  }

  if (!isset($_SESSION['quiz_'. $quiz->nid]['quiz_questions'])) {
    /* We delete questions in progress from old revisions... */
    _quiz_delete_old_in_progress($quiz, $user->uid);
    $rid = _quiz_active_result_id($user->uid, $quiz->nid, $quiz->vid);

    // Are we resuming an in-progress quiz?
    if ($rid > 0) {
      _quiz_resume_existing_quiz($quiz, $user->uid, $rid);
    }
    // First time running through quiz.
    elseif ($rid = quiz_start_check($quiz)) {
      // Create question list.
      $questions = quiz_build_question_list($quiz);

      if ($questions === FALSE) {
        drupal_set_message(t('Not enough random questions were found. Please !add_more_questions before trying to take this @quiz.',
          array('@quiz' => QUIZ_NAME, '!add_more_questions' => l(t('add more questions'), 'node/'. arg(1) .'/questions'))), 'error');
        return array('body' => array('#value' => ''));
      }

      if (count($questions) == 0) {
        drupal_set_message(t('No questions were found. Please !assign_questions before trying to take this @quiz.',
          array('@quiz' => QUIZ_NAME, '!assign_questions' => l(t('assign questions'), 'node/'. arg(1) .'/questions'))), 'error');
        return array('body' => array('#value' => t('Please assign questions...')));
      }

      // Initialize session variables.
      $_SESSION['quiz_'. $quiz->nid]['quiz_questions'] = $questions;
      $_SESSION['quiz_'. $quiz->nid]['question_number'] = 0;
      $_SESSION['quiz_'. $quiz->nid]['question_start_time'] = time();
      $_SESSION['quiz_'. $quiz->nid]['question_duration'] = $quiz->time_limit;
      $_SESSION['quiz_'. $quiz->nid]['quiz_vid'] = $quiz->vid;
    }

    else {
      return array('body' => array('#value' => ''));
    }
  }
  if (!isset($_POST['op'])) {
    // Starting new quiz... Do we need to show instructions here?
  }
  // Navigate backwards
  elseif ($_POST['op'] == t('Back')) {
    unset($_POST['tries']);

    // We maintain two lists -- previous questions and upcomming questions.
    // When we go backward, we pop one from the previous and prepend it to
    // the upcomming.
    // TODO: This can be maintained more efficiently with a single array of
    // all questions and then a pointer to the current question. That makes
    // rewinding much easier.
    $quiz_id = 'quiz_' . $quiz->nid;
    $last_q = array_pop($_SESSION[$quiz_id]['previous_quiz_questions']);
    array_unshift($_SESSION[$quiz_id]['quiz_questions'], $last_q);
    
  }
  // Check for answer submission.
  elseif ($_POST['op'] == t('Submit') || $_POST['op'] == t('Next')) {
    if (!isset($_SESSION['quiz_'. $quiz->nid]['result_id']))
      $_SESSION['quiz_'. $quiz->nid]['result_id'] = quiz_create_rid($quiz);

    // Previous quiz questions: Questions that have been asked already. We save a record of all of them
    // so that a user can navigate backward all the way to the beginning of the quiz.
    $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][0]['rid'] = $_SESSION['quiz_' . $quiz->nid]['result_id'];
    $_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions'][] = $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][0];
    $former_question_array = array_shift($_SESSION['quiz_'. $quiz->nid]['quiz_questions']);
    $former_question = node_load($former_question_array['nid'], $former_question_array['vid']);

    // Call hook_evaluate_question().
    $types = _quiz_get_question_types();
    $module = $types[$former_question->type]['module'];
    $result = module_invoke($module, 'evaluate_question', $former_question, $_SESSION['quiz_'. $quiz->nid]['result_id']);
    $q_passed_validation = $result->is_valid;
    quiz_store_question_result($result, array('set_msg' => TRUE));

    // Stash feedback in the session, since the $_POST gets cleared.
    if ($quiz->feedback_time == QUIZ_FEEDBACK_QUESTION) {
      // Invoke hook_get_report().
      //$report = module_invoke($former_question->type, 'get_report', $former_question_array['nid'], $former_question_array['vid'], $_SESSION['quiz_'. $quiz->nid]['result_id']);
      $report = module_invoke($module, 'get_report', $former_question_array['nid'], $former_question_array['vid'], $_SESSION['quiz_'. $quiz->nid]['result_id']);
      $path = drupal_get_path('module', 'quiz');
      require_once($path .'/quiz.pages.inc');
      $_SESSION['quiz_'. $quiz->nid]['feedback'] = rawurlencode(drupal_get_form('quiz_report_form',array($report)));
    }
    if ($quiz->repeat_until_correct) {
      // If the question was answered incorrectly, repeat it
      if ($result && !$result->is_correct && $result->is_evaluated) {
        $last_q = array_pop($_SESSION['quiz_' . $quiz->nid]['previous_quiz_questions']);
        array_unshift($_SESSION['quiz_' . $quiz->nid]['quiz_questions'], $last_q);
        drupal_set_message(t('The answer was incorrect. Please try again.'), 'error');
      }
    }
 
    // If anonymous user, refresh url with unique hash to prevent caching.
    if (!$user->uid) {
      //drupal_goto('node/'. $quiz->nid .'/quiz/start/'. md5(mt_rand() . time())); #460550
      drupal_goto('node/'. $quiz->nid .'/take', array('quizkey' => md5(mt_rand() . time())));
    }
  }
  // Check for a skip.
  elseif ($_POST['op'] == t('Skip') && $allow_skipping) {
    if (!isset($_SESSION['quiz_'. $quiz->nid]['result_id']))
      $_SESSION['quiz_'. $quiz->nid]['result_id'] = quiz_create_rid($quiz);
    $q_passed_validation = TRUE;
    // Advance the question.
    $_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions'][] = $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][0];

    // Load the last asked question.
    $former_question_array = array_shift($_SESSION['quiz_'. $quiz->nid]['quiz_questions']);
    $former_question = node_load($former_question_array['nid'], $former_question_array['vid']);

    // Call hook_skip_question().
    $module = quiz_question_module_for_type($former_question->type);
    $result = module_invoke($module, 'skip_question', $former_question, $_SESSION['quiz_'. $quiz->nid]['result_id']);

    // Report that the question was skipped:
    //quiz_store_question_result($former_question_array['nid'], $former_question_array['vid'], $_SESSION['quiz_'. $quiz->nid]['result_id'], $result);
    quiz_store_question_result($result, array('set_msg' => TRUE));
  }
  // The content array:
  //$content['body'] = array();

  // If this quiz is in progress, load the next questions and return it via the theme.
  if (!empty($_SESSION['quiz_'. $quiz->nid]['quiz_questions']) || is_string($q_passed_validation)) {
    if (!is_string($q_passed_validation)) {
      $question_node = node_load(
        $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][0]['nid'],
        $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][0]['vid']
      );
      $question_node->rid = $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][0]['rid'];
    } else {
      $question_node = $former_question;
      drupal_set_message($q_passed_validation, 'error');
      array_unshift($_SESSION['quiz_'. $quiz->nid]['quiz_questions'], $former_question_array);
      if (is_array($_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions']))
        array_shift($_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions']);
    }
    //$output .= theme('quiz_take_question', $quiz, $question_node);
    // Start mods...

    $number_of_questions = quiz_get_number_of_questions($quiz->vid, $quiz->nid);
    $question_number = $number_of_questions - count($_SESSION['quiz_'. $quiz->nid]['quiz_questions']);
    $question_node->question_number = $question_number;
    $content['progress']['#value'] = theme('quiz_progress', $question_number, $number_of_questions);
    $content['progress']['#weight'] = -50;

    if ($_SESSION['quiz_'. $quiz->nid]['question_duration']) {
      $_SESSION['quiz_'. $quiz->nid]['question_duration'] -= time() - $_SESSION['quiz_'. $quiz->nid]['question_start_time'];
      /*
      if ($_SESSION['quiz_'. $quiz->nid]['question_duration'] < -10) {
        unset($_SESSION['quiz_'. $quiz->nid]);
        drupal_set_message('You have left this quiz partially complete.');
        return ;
      }
      */
      $time = ($_SESSION['quiz_'. $quiz->nid]['question_duration'] > 0) ? $_SESSION['quiz_'. $quiz->nid]['question_duration'] : 1;
      db_query("UPDATE {quiz_node_results} SET time_left = %d WHERE result_id = %d", $time, $_SESSION['quiz_'. $quiz->nid]['result_id']);

      if ($time == 1) {
        /* Quiz has been timed out, run a loop to mark the remaining questions
         * as skipped */
        while (!empty($_SESSION['quiz_'. $quiz->nid]['quiz_questions'])) {
          $_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions'][] = $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][0];
          $former_question_array = array_shift($_SESSION['quiz_'. $quiz->nid]['quiz_questions']);
          $former_question = node_load($former_question_array['nid'], $former_question_array['vid']);

          // Call hook_skip_question().
          $module = quiz_question_module_for_type($former_question->type);
          $result = module_invoke($module, 'skip_question', $former_question, $_SESSION['quiz_'. $quiz->nid]['result_id']);

         // Report that the question was skipped:
         //quiz_store_question_result($former_question_array['nid'], $former_question_array['vid'], $_SESSION['quiz_'. $quiz->nid]['result_id'], $result);
          quiz_store_question_result($result, array('set_mesg' => FALSE));
        }
        $_SESSION['quiz_'. $quiz->nid]['quiz_questions'] = array();
        // empty the quiz questions
        // We're at the end of the quiz, so set a flag saying so.
        $quiz_end = TRUE;
        drupal_set_message(t('You have run out of time.'), 'error');
      }
      else {
        // There is still time left, so let's go ahead and insert the countdown javascript.
        if (function_exists('jquery_countdown_add') && variable_get('quiz_has_timer', 1)) {
          jquery_countdown_add('.countdown', array('until' => $time, 'onExpiry' => 'finished'));
          // These are the two button op values that are accepted for answering questions.
          $button_op1 = drupal_to_js(t('Submit'));
          $button_op2 = drupal_to_js(t('Next'));
          $js = "
            function finished() {
              // Find all buttons with a name of 'op'.
              var buttons = $('input[type=submit][name=op], button[type=submit][name=op]');
              // Filter out the ones that don't have the right op value.
              buttons = buttons.filter(function() {
                return this.value == $button_op1 || this.value == $button_op2;
              });
              if (buttons.length == 1) {
                // Since only one button was found, this must be it.
                buttons.click();
              }
              else {
                // Zero, or more than one buttons were found; fall back on a page refresh.
                window.location = window.location.href;
              }
            }
          ";
          drupal_add_js($js, 'inline');
          //window.location.reload() method doesn't works here.
        }
      }
      $_SESSION['quiz_'. $quiz->nid]['question_start_time'] = time();
    }
    // If we're not yet at the end.
    if (empty($quiz_end)) {
      // Basically, we store the results of what would normally be a node_view() of the question node in
      // the $content for the quiz node. Since we want to override the default theme, we use the
      // quiz_node_view() function, which performs the steps in node_view(), but in a way more
      // specific to our needs.
      $content['body']['question']['#value'] = quiz_node_view($question_node, $quiz);
      $content['body']['question']['#weight'] = 0;
      // If we had feedback from the last question.
      if (isset($_SESSION['quiz_'. $quiz->nid]['feedback']) && $quiz->feedback_time == QUIZ_FEEDBACK_QUESTION) {
        $content['body']['feedback']['#value'] = rawurldecode($_SESSION['quiz_'. $quiz->nid]['feedback']);
        $content['body']['feedback']['#weight'] = -100;
        //$output .= rawurldecode($_SESSION['quiz_'. $quiz->nid]['feedback']);
      }
      drupal_set_title(check_plain($quiz->title));
      unset($_SESSION['quiz_'. $quiz->nid]['feedback']);
    }
  }
  // Else we're at the end of quiz.
  else {
    $quiz_end = TRUE;
  }
  // If we're at the end of the quiz.
  if (!empty($quiz_end)) {
    $score = quiz_end_actions($quiz, $_SESSION['quiz_'. $quiz->nid]['result_id']);
    //print_r($score);exit;Array ( [question_count] => 2 [possible_score] => 2 [numeric_score] => 2 [percentage_score] => 100 [is_evaluated] => 1 )

    if ($quiz->feedback_time == QUIZ_FEEDBACK_NEVER) {
      $content['body']['#value'] = theme('quiz_no_feedback');
    }
    else {
      // Get the results and summary text for this quiz.
      $questions = _quiz_get_answers($_SESSION['quiz_'. $quiz->nid]['result_id']);
      $summary = _quiz_get_summary_text($quiz, $score);
      // Get the themed summary page.
      $content['body']['#value'] = theme('quiz_take_summary', $quiz, $questions, $score, $summary);
    }
    if ($score['is_evaluated']) {
      _quiz_maintain_results($quiz, $_SESSION['quiz_'. $quiz->nid]['result_id']);
    }

    // Remove session variables.
    unset($_SESSION['quiz_'. $quiz->nid]);
  }
  //return $output;
  return $content;
}

/**
 * Basically replace node_view() for questions that are to be rendered into a quiz page.
 *
 * @param $question_node
 *  The question node that should be rendered.
 * @return
 *  A string containing the body of the node.
 */
function quiz_node_view($question_node, $quiz_node) {
  $question_node->allow_skipping = $quiz_node->allow_skipping;
  $question_node = node_build_content($question_node, FALSE, TRUE);
  node_invoke_nodeapi($question_node, 'alter', FALSE, TRUE);
  $question_node->body = drupal_render($question_node->content);
  return theme('quiz_single_question_node', $question_node);
}

/**
 * Store a quiz question result.
 *
 * @param $result
 *  stdClass object with the following attributes:
 *  - nid, vid, rid, is_correct, score (default: 1 if correct, 0 otherwise), is_skipped (default: FALSE)
 */
function quiz_store_question_result($result, $options) {
  if (isset($result->is_skipped) && $result->is_skipped == TRUE) {
    if ($options['set_msg']) {
      drupal_set_message(t('Last question skipped.'), 'status');
    }
    $result->is_correct = FALSE;
    $result->score = 0;
  }
  else {
    // Make sure this is set.
    $result->is_skipped = FALSE;
  }
  if (!isset($result->score)) {
    $result->score = $result->is_correct ? 1 : 0;
  }

  $rid_count = db_result(db_query("SELECT COUNT('result_id') AS count FROM {quiz_node_results_answers} WHERE question_nid = %d AND question_vid = %d AND result_id = %d", $result->nid, $result->vid, $result->rid));
  if ($rid_count > 0) {
    db_query("UPDATE {quiz_node_results_answers}
      SET is_correct = %d, points_awarded = %d, answer_timestamp = %d, is_skipped = %d
      WHERE question_nid = %d AND question_vid = %d AND result_id = %d",
      $result->is_correct, $result->score, time(), $result->is_skipped, $result->nid, $result->vid, $result->rid);
  }
  else {
    db_query("INSERT INTO {quiz_node_results_answers}
      (question_nid, question_vid, result_id, is_correct, points_awarded, answer_timestamp, is_skipped)
      VALUES (%d, %d, %d, %d, %d, %d, %d)",
      $result->nid, $result->vid, $result->rid, $result->is_correct, $result->score, time(), $result->is_skipped);
  }
}

/**
 * Actions to take at the end of a quiz.
 */
function quiz_end_actions($quiz, $rid) {
  global $user;
  $score = quiz_calculate_score($quiz, $rid);
  if (!isset($score['percentage_score'])) {
    $score['percentage_score'] = 0;
  }
  // Why is this using the $_SESSION's RID?
  db_query("UPDATE {quiz_node_results} SET is_evaluated = %d, time_end = %d, score = %d WHERE result_id = %d", $score['is_evaluated'], time(), $score['percentage_score'], $_SESSION['quiz_'. $quiz->nid]['result_id']);
  $score['passing'] = quiz_is_passed($user->uid, $quiz->nid, $quiz->vid);
  
  // Lets piggy back here to perform the quiz defined action since were done with this quiz.
  // We will verify that there is an associated action with this quiz and then perform that action.
  if (!empty($quiz->aid)) {
    /*
     * Some actions are reliant on objects and I am unsure which ones, for now I have simply
     * passed the actions_do() function an empty array.  By passing this function a single id
     * then it will retrieve the callback, get the parameters and perform that function (action)
     * for you.
     * @TODO: Add ability to assign multiple actions and pass the actions_do() an array of aid's
     * @TODO: Create feature to only fire action if certain score is reached.
     */
    $context = array(
      'result_id' => $rid,
      'score' => $score,
    );
    actions_do($quiz->aid, $quiz, $context, $score);
  }

  // Call hook_quiz_finished().
  module_invoke_all('quiz_finished', $quiz, $score, $rid);
  return $score;
}

/*
 *
 * Implementation hook_quiz_finished()
 * performs actions like sending quiz results over email at the end of quiz.
 */

function quiz_quiz_finished($quiz, $score, $rid) {
  global $user;

  //function to send results over e-mail

  /*
   * For personality kind of quizzes
   * if the user is an anonymous and configured to send user result to author
   * send mail to author's e-mail id
   */

  if ($user->uid == 0 && variable_get('quiz_results_to_quiz_author', 0)) {
    $author = user_load($quiz->uid);
    drupal_mail('quiz', 'notice', $author->mail, NULL, array($quiz,
$score, $rid));
  }

  /*
   * For e-Learning kind of quizzes
   * if quiz has pass/fail, configured to send results to attendee and attendee is
   * NOT an anonymous send result to his/her e-mail ID.
   */
  if (variable_get('quiz_email_results', 0) && variable_get('quiz_use_passfail', 1) && $user->uid != 0) {
    drupal_mail('quiz', 'notice', $user->mail, NULL, array($quiz, $score, $rid));
    drupal_set_message(t('Your results have been sent to your e-mail address.'));
  }

  //calls userpoints functions to credit user point based on number of correct answers
  //print_r($quiz);exit;
  if ($quiz->has_userpoints) {
    $variables = array(
      '@title' => $quiz->title,
      '@quiz' => variable_get('quiz_name', QUIZ_NAME),
      '@time' => date('l jS \of F Y h:i:s A'),
    );
    $params = array(
      'points' => $score['numeric_score'],
      'description' => t('Attened @title @quiz on @time', $variables),
    );
    userpoints_userpointsapi($params);
  }
}


/*
 *
 * Implementation of hook_mail
 * sends quiz result to user email
 */

function quiz_mail($key, &$message, $params) {
  global $user;
  list($quiz, $score, $rid) = $params;
  $substitutions = array(
    '!title' => $quiz->title,
    '!sitename' => variable_get('site_name', 'Quiz'),
    '!username' => ($user->uid) ? $user->name : $quiz->name,
    /* if the user is anonymous user use quiz author's name
    else use quiz attendee's name.
    */
    '!user' => ($user->uid) ? 'You have' : 'Anonymous user has',
    '!title' => $quiz->title,
    '!date' => date("F j, Y, g:i a"),
    '!desc' => $quiz->body,
    '!correct' => isset($score['numeric_score']) ? $score['numeric_score'] : 0,
    '!total' => $score['question_count'],
    '!percentage' => $score['percentage_score'],
    '!url' => url('user/quiz/' . $rid . '/userresults', array('absolute' => TRUE)),
    '!time' => db_result(db_query("SELECT floor((time_end - time_start)/60) FROM {quiz_node_results} WHERE result_id = '%d' AND time_end", $rid))
  );

  switch ($key) {
    case 'notice':
      $subject = variable_get('quiz_email_results_subject', quiz_email_results_format('subject'));
      $body = variable_get('quiz_email_results_body', quiz_email_results_format('body'));

      foreach ($substitutions as $key => $value) {
        $subject = str_replace($key, $value, $subject);
        $body = str_replace($key, $value, $body);
       }
      $message['subject'] = $subject;
      $message['body'] = $body;
    break;
  }
}

/*
 * This functions returns the default email subject and body format which will be used at the end of quiz
 */

function quiz_email_results_format($type) {
  global $user;
  if ($type == 'subject') {
    return t('!title Results Notice from !sitename');
  }
  if ($type == 'body') {
    return t('Dear !username') . "\n\n" .
      t('!user attended a !title quiz on !date') . "\n" .
      t('Test Description : !desc') . "\n" .
      t('!user got !correct out of !total in !time min percentage is !percentage') . "\n" .
      t('You can access your result here !url') . "\n";
  }
}
/**
 * Update a score for a quiz.
 *
 * This updates the quiz node results table.
 *
 * It is used in cases where a quiz score is changed after the quiz has been taken. For example,
 * if a long answer question is scored later by a human, then the quiz should be updated when that answer
 * is scored.
 *
 * Important: The value stored in the table is the *percentage* score.
 *
 * @param $quiz
 *  The quiz node for the quiz that is being scored.
 * @param $rid
 *  The result ID to update.
 * @return
 *  The score as an integer representing percentage. E.g. 55 is 55%.
 */
function quiz_update_total_score($quiz, $rid) {
  $score = quiz_calculate_score($quiz, $rid);
  db_query('UPDATE {quiz_node_results} SET score = %d WHERE result_id = %d', $score['percentage_score'], $rid);
  if ($score['is_evaluated']) {
    // Call hook_quiz_scored().
    module_invoke_all('quiz_scored', $quiz, $score, $rid);
    _quiz_maintain_results($quiz, $rid);
    db_query('UPDATE {quiz_node_results} SET is_evaluated = 1 WHERE result_id = %d', $rid);
  }
  return $score['percentage_score'];
}

/**
 * Get feedback for one question.
 *
 * Good for displaying feedback after every question instead of all at the end.
 *
 * @param $quiz
 *  The quiz node.
 * @param $report
 *  The question node and its calculated results.
 * @return
 *  Themed feedback for output.
 */
function quiz_get_feedback($quiz, $report) {
  return theme('quiz_single_question_feedback', $quiz, $report);
}

/**
 * Get answers the user actually tried.
 *
 * @param $answers
 *  The question answers.
 * @param $tried
 *  The user selected answers.
 * @return
 *  An array of user-selected answer keys.
 */
function quiz_get_answers($answers, $tried) {
  $selected = array();
  if (is_array($answers)) {
    foreach ($answers as $key => $answer) {
      if (($key = array_search($answer['aid'], $tried)) !== FALSE) {
        $selected[] = $answer;
        // Correct answer was selected, so lets take that out the tried list.
        unset($tried[$key]);
      }
    }
  }
  return $selected;
}

/**
 * Get an array of correct answer(s) for a question.
 *
 * @param $answers
 *  An array of question answers.
 * @return
 *  An array of correct answers.
 */
function quiz_get_corrects($answers) {
  if (is_array($answers)) {
    foreach ($answers as $answer) {
      if ($answer['is_correct'] > 0) {
        $corrects[] = $answer;
      }
    }
  }
  return $corrects;
}

/**
 * Check a user/quiz combo to see if the user passed the given quiz.
 * A quiz is keyed by nid/vid, so you need both.
 * This will return TRUE if the user has passed the quiz at least once, and
 * false otherwise. Note that a FALSE may simply indicate that the user has not
 * taken the quiz.
 * @param $uid
 *  The user ID.
 * @param $nid
 *  The node ID.
 * @param $vid
 *  The version ID.
 */
function quiz_is_passed($uid, $nid, $vid) {
  $passed = db_result(db_query("SELECT COUNT(result_id) AS passed_count
    FROM {quiz_node_results} qnrs
    INNER JOIN {quiz_node_properties} USING (vid, nid)
    WHERE qnrs.vid = %d AND qnrs.nid = %d AND qnrs.uid =%d AND score >= pass_rate",
    $vid, $nid, $uid
  ));
  // Force into boolean context
  return ($passed !== FALSE && $passed > 0);
}

/**
 * Actions to take place at the start of a quiz.
 *
 * This is called when the quiz node is viewed for the first time. It ensures that
 * the quiz can be taken at this time.
 *
 * @param $quiz
 *  The quiz node.
 * @return
 *  Returns quiz_node_results result_id, or FALSE if there is an error.
 */
function quiz_start_check($quiz) {
  global $user;

  $user_is_admin = user_access('edit any quiz') || (user_access('edit own quiz') && $quiz->uid == $user->uid);

  // Make sure this is available.
  if ($quiz->quiz_always != 1) {
    // Compare current GMT time to the open and close dates (which should still be in GMT time).
    $now = gmmktime();

    if ($now >= $quiz->quiz_close || $now < $quiz->quiz_open) {
      if ($user_is_admin) {
        drupal_set_message(t('You are marked as an administrator or owner for this quiz. While you can take this quiz, the open/close times prohibit other users from taking this quiz.'), 'status');
      }
      else {
        drupal_set_message(t('This @quiz is not currently available.', array('@quiz' => QUIZ_NAME)), 'status');
        // Can't take quiz.
        return FALSE;
      }
    }
  }

  // Check to see if this user is allowed to take the quiz again:
  if ($quiz->takes > 0) {
    $query = "SELECT COUNT(*) AS takes FROM {quiz_node_results} WHERE uid = '%s' AND nid = '%s' AND vid = '%s'";
    $taken = db_result(db_query($query, $user->uid, $quiz->nid, $quiz->vid));
    $allowed_times = format_plural($quiz->takes, '1 time', '@count times');
    $taken_times   = format_plural($taken, '1 time', '@count times');

    // The user has already taken this quiz (nid/vid combo).
    if ($taken) {
      if ($user_is_admin) {

        drupal_set_message(t('You have taken this quiz already. You are marked as an owner or administrator for this quiz, so you can take this quiz as many times as you would like.'), 'status');
      }
      // If the user has already taken this quiz too many times, stop the user.
      elseif ($taken >= $quiz->takes) {
        drupal_set_message(t('You have already taken this quiz @really. You may not take it again.', array('@really' => $taken_times)), 'error');
        return FALSE;
      }
      // If the user has taken the quiz more than once, see if we should report this.
      elseif (variable_get('quiz_show_allowed_times', TRUE)) {
        drupal_set_message(t("You can only take this quiz @allowed. You have taken it @really.", array('@allowed' => $allowed_times, '@really' => $taken_times)), 'status');
      }
    }
  }

  // Check to see if the (a) user is registered, and (b) user alredy passed this quiz.
  if ($user->uid && quiz_is_passed($user->uid, $quiz->nid, $quiz->vid)) {
      drupal_set_message(t('You have already passed this @quiz.', array('@quiz' => QUIZ_NAME)), 'status');
  }

  // On error, we want to return before here to avoid creating an empty entry in quiz_node_results.
  // Otherwise, we get fairly cluttered Quiz Results.

  // Insert quiz_node_results record.
  // $result = db_query(
  //     "INSERT INTO {quiz_node_results} (result_id, nid, vid, uid, time_start) VALUES (%d, %d, %d, %d, %d)",
  //     $rid, $quiz->nid, $quiz->vid, $user->uid, time()
  //   );

  // Call hook_quiz_begin().
  module_invoke_all('quiz_begin', $quiz, $rid);

  return TRUE;
}

function quiz_create_rid($quiz) {
  global $user;
  $result = db_query(
    "INSERT INTO {quiz_node_results} (nid, vid, uid, time_start) VALUES (%d, %d, %d, %d)",
    $quiz->nid, $quiz->vid, $user->uid, time()
  );

  if ($result) {
    // Return the last RID.
    $rid = db_last_insert_id('quiz_node_results', 'result_id');
  }
  else {
    drupal_set_message(t('There was a problem starting the @quiz. Please try again later.', array('@quiz' => QUIZ_NAME), 'error'));
    return FALSE;
  }
  return $rid;
}

/**
 * Calculates the score user received on quiz.
 *
 * @param $quiz
 *  The quiz node.
 * @param $rid
 *  Quiz result ID.
 * @return array
 *  Contains three elements: question_count, num_correct and percentage_score.
 */
function quiz_calculate_score($quiz, $rid) {
  //TODO: Consider removing total score and use database value instead...
  // 1. Get each question for the quiz.
  /*
  $sql = 'SELECT qnr.child_nid, qnr.child_vid , n.type
    FROM {quiz_node_relationship} qnr
    INNER JOIN {node} n ON n.nid = qnr.child_nid
    WHERE qnr.parent_nid = %d';
  $results = db_query($sql, $quiz->nid);
  */
  $sql = 'SELECT question_nid, question_vid, type, max_score
  FROM {quiz_node_results_answers} a
  LEFT JOIN {node} n ON (question_nid = nid)
  LEFT JOIN {quiz_node_relationship} r ON (r.child_vid = a.question_vid)
  WHERE result_id = %d AND r.parent_vid = %d';
  $results = db_query($sql, $rid, $quiz->vid);


  // 2. Callback into the modules and let them do the scoring.
  $scores = array();
  $count = 0;
  while ($question = db_fetch_object($results)) {
    // Invoke hook_quiz_question_score().
    // We don't use module_invoke() because (1) we don't necessarily want to wed quiz type to
    // module, and (2) this is more efficient -- no NULL checks.
    $mod = quiz_question_module_for_type($question->type);
    $function = $mod . '_quiz_question_score';

    if (function_exists($function)) {
      $score = $function($quiz, $question->question_nid, $question->question_vid, $rid);
      $score->attained = ($score->possible > 0) ? ($score->attained / $score->possible * $question->max_score) : 0;
      $score->possible = $question->max_score;
      $scores[] = $score;
    }
    else {
      drupal_set_message(t('A quiz question could not be scored: No scoring info is available'), 'error');
      $dummy_score = new stdClass();
      $dummy_score->possible = 0;
      $dummy_score->attained = 0;
      $scores[] = $dummy_score;
    }
    ++$count;
  }
  // 3. Sum the results
  $possible_score = 0;
  $total_score = 0;
  $is_evaluated = TRUE;
  foreach ($scores as $score) {
    $possible_score += $score->possible;
    $total_score += $score->attained;
    if (isset($score->is_evaluated)) {
      // Flag the entire quiz if one question has not been
      // evaluated.
      $is_evaluated &= $score->is_evaluated;
    }
  }

  // 4. Return the score
  return array(
    'question_count' => $count,
    'possible_score' => $possible_score,
    'numeric_score' => $total_score,
    'percentage_score' => ($possible_score == 0) ? 0 : round(($total_score * 100) / $possible_score),
    'is_evaluated' => $is_evaluated,
  );
}

/**
 *
 * @param $type
 * @return string
 *   name of module matching the question type, as given by quiz_question_info hook
 */
function quiz_question_module_for_type($type) {
  $types = _quiz_get_question_types();
  return $types[$type]['module'];
}

/**
 * Retrieves a question list for a given quiz.
 *
 * @param $quiz
 *  Quiz node.
 * @return
 *  Array of question node IDs.
 */
function quiz_build_question_list($quiz) {
  $questions = array();

  // Get required questions first.
  $sql = "SELECT child_nid as nid, child_vid as vid
    FROM {quiz_node_relationship}
    WHERE parent_vid = %d
      AND question_status = %d
    ORDER BY weight";
  $result = db_query($sql, $quiz->vid, QUESTION_ALWAYS);
  while ($question_node = db_fetch_array($result)) {
    $questions[] = $question_node;
  }

  // Get random questions for the remainder.
  if ($quiz->number_of_random_questions > 0) {
    //$questions = array_merge($questions, _quiz_get_random_questions($quiz->number_of_random_questions, $quiz->tid));
    $questions = array_merge($questions, _quiz_get_random_questions($quiz));
    if ($quiz->number_of_random_questions > count($questions)) {
      // Unable to find enough requested random questions.
      return FALSE;
    }
  }

  // Shuffle questions if required.
  if ($quiz->randomization > 0) {
    shuffle($questions);
  }
  return $questions;
}

/**
 * Gets the number questions of a given type for a quiz.
 *
 * @param $nid
 *  Node ID of the quiz.
 * @param $type
 *  Status constant.
 * @return
 *  Number of questions that meet the criteria.
 */
function quiz_get_num_questions($nid, $vid, $type) {
  return db_result(db_query("SELECT COUNT('parent_vid') FROM {quiz_node_relationship} WHERE parent_vid = %d AND parent_nid = %d AND question_status = %d", $vid, $nid, $type));
}

/**
 * Map node properties to a question object.
 *
 * @param $node
 *  Node
 * @return
 *  Question object
 */
function quiz_node_map($node, $include_question = TRUE) {
  $new_question = new stdClass();
  if ($include_question)
    $new_question->question = check_markup($node->body, $node->format, FALSE);
  $new_question->title = check_plain($node->title);
  $new_question->nid = $node->nid;
  $new_question->vid = $node->vid;
  $new_question->type = $node->type;
  $new_question->latest_vid = $node->latest_vid;
  $new_question->question_status = isset($node->question_status) ? $node->question_status : QUESTION_NEVER;
  if (isset($node->max_score)) $new_question->max_score = $node->max_score;
  $new_question->weight = $node->weight;
  return $new_question;
}

/**
 * Sets the questions that are assigned to a quiz.
 *
 * @param $quiz
 *   The quiz to modify.
 * @param $questions
 *   An array of questions.
 * @param $set_new_revision
 *   If TRUE, a new revision will be generated. Note that saving
 *  quiz questions unmodified will still generate a new revision of the quiz if this
 *  is set to TRUE. Why? For a few reasons:
 *  - All of the questions are updated to their latest VID. That is supposed to be a feature.
 *  - All weights are updated
 *  - All status flags are updated
 * @return
 *   Boolean TRUE if update was successful, FALSE otherwise.
 */
function quiz_set_questions(&$quiz, $questions, $set_new_revision = FALSE) {
  $old_vid = $quiz->vid;
  if ($set_new_revision) {
    // Create a new Quiz VID, even if nothing changed.
    $quiz->revision = 1;
    node_save($quiz);
  }

  // XXX: Should we be verifying here that the nodes submitted as $questions are actually
  // recognized question types? It adds quite a performance hit, but could be beneficial.

  // When node_save() calls all of the node API hooks, old quiz info is automatically
  // inserted into quiz_node_relationship. We could get clever and try to do strategic
  // updates/inserts/deletes, but that method has already proven error prone as the module
  // has gained complexity (See 5.x-2.0-RC2).
  // So we go with the brute force method:
  db_query('DELETE FROM {quiz_node_relationship} WHERE parent_nid = %d AND parent_vid = %d', $quiz->nid, $quiz->vid);

  if (empty($questions)) {
    return TRUE; // This is not an error condition.
  }

  // Now we do an insert of everything in the quiz. (Note that we are using a subselect to get the most recent vid.)

  $refresh_sql = "INSERT INTO {quiz_node_relationship} (parent_nid, parent_vid, child_nid, child_vid, question_status, weight, max_score)
      VALUES (%d, %d, %d, (SELECT vid FROM {node} WHERE nid = %d), %d, %d, %d)";

  $norefresh_sql = "INSERT INTO {quiz_node_relationship} (parent_nid, parent_vid, child_nid, child_vid, question_status, weight, max_score)
      VALUES (%d, %d, %d, %d, %d, %d, %d)";
  $total_max_score = 0;
  foreach ($questions as $question) {
    if ($question->state != QUESTION_NEVER) {
      if ($question->refresh) {
        //drupal_set_message(t("Doing insert for %nid-%vid-%cnid-%cvid: %stat", array('%nid' => $quiz->nid, '%vid' => $quiz->vid, '%cnid' => $question->nid, '%cvid' => $question->vid, '%stat' => $question->status)));
        $result = db_query($refresh_sql, $quiz->nid, $quiz->vid, $question->nid, $question->nid, $question->state, $question->weight, $question->max_score);
      }
      else {
        $result = db_query($norefresh_sql, $quiz->nid, $quiz->vid, $question->nid, $question->vid, $question->state, $question->weight, $question->max_score);
      }
    }
    $total_max_score += $question->max_score;
  }
  $sql = 'UPDATE {quiz_node_properties} SET max_score = %d WHERE nid = %d AND vid = %d';
  db_query($sql, $total_max_score, $quiz->nid, $quiz->vid);
  return TRUE;
}

/**
 * Updates the status of questions assigned to the quiz. Possible statuses
 * are 'random', 'always', 'never'.
 *
 * @access public
 * @param &$quiz
 *  The quiz node. This is modified internally.
 * @param $submitted_questions
 *  Array of submitted question statuses indexed (keyed) by the question nid. If this
 *  is empty, all of the quiz questions will be deleted from this quiz.
 * @return boolean
 *  True if update was a success, false if there was a problem.
 * @deprecated See quiz_set_questions() for the new version.
 */
function quiz_update_questions(&$quiz, $submitted_questions, $revision = FALSE) {

  // No questions to update, so return now.
  if (empty($submitted_questions)) {
    return FALSE; // This will cause an error message.
  }

  // Loop through all questions and determine whether an update needs to be made.
  // As we go, we store the questions that will need to be updated.
  $existing_questions = _quiz_get_questions($quiz->nid, $quiz->vid, TRUE, TRUE);
  $existing_question_nids = array_keys($existing_questions);
  $i_am_different = FALSE;
  $questions = array(); // These are the questions that will be put into the Quiz.
  foreach ($submitted_questions as $nid => $stat) {
    $existing = in_array($nid, $existing_question_nids);// $existing_questions[$nid];
    if ($stat != QUESTION_NEVER) {
      if ($existing) {
        $existing_question = $existing_questions[$nid];
        // This appears to be comparing publishing status with question_status?
        if ($existing_question->question_status != $stat) {
          // Question's status has been changed.
          $existing_question->question_status = $stat;
          $i_am_different = TRUE;
        }
        // else This question is the same. Do nothing.
        $questions[] = $existing_question;
      }
      else {
        $new_question = node_load($nid);
        $new_question->question_status = $stat;
        $questions[] = $new_question;
        // A new question was added to the quiz.
        $i_am_different = TRUE;
      }
    }
    // Question is marked never, but it was something else on the last version of the quiz.
    elseif (!empty($existing) && $stat != $existing->question_status) {
      // Delete items moved from ALWAYS or RANDOM to NEVER
      $existing->question_status = $stat;
      $questions[] = $existing;
      $i_am_different = TRUE;
    }
    // else Question isn't on the quiz, and isn't marked for inclusion.
    //else {
      // Question isn't part of the quiz.
    //}
  }

  if (!$i_am_different) {
    // Nothing else to do.
    return TRUE;
  }

  // If we get here, then we (may) need to create a new VID and then store the questions.

  if ($revision) {
    // Create a new Quiz VID
    $quiz->revision = 1; // Need new vid.
    node_save($quiz); // This updates the $quiz referent.
  }

  // When node_save() calls all of the node API hooks, old quiz info is automatically
  // inserted into quiz_node_relationship. We could get clever and try to do strategic
  // updates/inserts/deletes, but that method has already proven error prone as the module
  // has gained complexity (See 5.x-2.0-RC2).
  // So we go with the brute force method:
  db_query('DELETE FROM {quiz_node_relationship} WHERE parent_nid = %d AND parent_vid = %d', $quiz->nid, $quiz->vid);

  // Now we do an insert of everything in the quiz.
  $sql = "INSERT INTO {quiz_node_relationship} (parent_nid, parent_vid, child_nid, child_vid, question_status)
      VALUES (%d, %d, %d, %d, %d)";

  foreach ($questions as $question) {
    if ($question->question_status != QUESTION_NEVER) {
      //drupal_set_message(t("Doing insert for %nid-%vid-%cnid-%cvid: %stat", array('%nid' => $quiz->nid, '%vid' => $quiz->vid, '%cnid' => $question->nid, '%cvid' => $question->vid, '%stat' => $question->status)));
      $result = db_query($sql, $quiz->nid, $quiz->vid, $question->nid, $question->vid, $question->question_status);
    }
  }

  return TRUE;
}

// End of "Public" Functions

/**
 * Resume an in-progress quiz.
 *
 * This sets the user's session back to the state it was in when the quiz was aborted.
 *
 * This function should only be called if the quiz needs resuming. Outside logic needs to
 * check that, though.
 *
 * @param $quiz
 *   The current quiz.
 * @param $uid
 *   The ID of the current user.
 * @param $rid
 *   The result ID found for the current quiz.
 */
function _quiz_resume_existing_quiz($quiz, $uid, $rid) {
  // Create question list.
  $questions = quiz_build_question_list($quiz);
  $already_answered = array();

  // Now we need to make sure to set previous questions to be correct.
  // This includes corrections for cases where questions were shuffled.

  $sql = "SELECT question_nid AS nid, question_vid AS vid
    FROM {quiz_node_results_answers} WHERE result_id = %d ORDER BY answer_timestamp";
  $answered_questions = db_query($sql, $rid);
  while ($answered = db_fetch_object($answered_questions)) {
    foreach ($questions as $question) {
      if ($question['vid'] == $answered->vid) {
        $already_answered[] = $answered->vid;
      }
    }
  }

  reset($questions);
  $_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions'] = array();
  $_SESSION['quiz_'. $quiz->nid]['quiz_questions'] = array();

  foreach ($questions as $question) {
    if (in_array($question['vid'], $already_answered)) {
      $_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions'][] = $question;
    }
    else {
      $_SESSION['quiz_'. $quiz->nid]['quiz_questions'][] = $question;
    }
  }

  $_SESSION['quiz_'. $quiz->nid]['result_id'] = $rid;
  $_SESSION['quiz_'. $quiz->nid]['question_number'] = count($_SESSION['quiz_'. $quiz->nid]['previous_quiz_questions']);

  // Timed quizzes are likely to have expired by this point. But we let
  // the quiz_take_quiz handler handle that.
  $_SESSION['quiz_'. $quiz->nid]['question_start_time'] = time();
  $_SESSION['quiz_'. $quiz->nid]['question_duration'] = $quiz->time_limit;

  drupal_set_message(t('Resuming a previous quiz in-progress.'), 'status');
}

/**
 *
 * @param $quiz
 *   A quiz node where old in progress results shall be deleted
 * @param $uid
 *   The userid of the user the old in progress results belong to
 */
function _quiz_delete_old_in_progress($quiz, $uid) {
  $sql = "DELETE FROM {quiz_node_results_answers}
          WHERE question_nid = %d
          AND question_vid < %d
          AND result_id IN (
            SELECT qnr.result_id
            FROM {quiz_node_results} qnr
            WHERE qnr.uid = %d
            AND qnr.nid = %d
            AND qnr.time_end = 0
          )";
  db_query($sql, $quiz->nid, $quiz->vid, $uid, $quiz_nid);

  $sql = "DELETE FROM {quiz_node_results}
          WHERE uid = %d
          AND nid = %d
          AND vid < %d
          AND time_end = 0";
  db_query($sql, $uid, $quiz->nid, $quiz->vid);
}

/**
 * Returns the result ID for any current result set for the given quiz.
 *
 * @param $uid
 *   User ID
 * @param $nid
 *   Quiz node ID
 * @param $vid
 *   Quiz node version ID
 * @param $now
 *   Timestamp used to check whether the quiz is still open. Default: current time.
 *
 * @return
 *   If a quiz is still open and the user has not finished the quiz,
 *   return the result set ID so that the user can continue.
 *
 *   If no quiz is in progress, this will return 0.
 */
function _quiz_active_result_id($uid, $nid, $vid, $now = NULL) {
  if (!isset($now)) {
    $now = time();
  }

  // Get any quiz that is (a) open, (b) for this user, and (c) has not already
  // been completed.
  $sql = "SELECT result_id
    FROM {quiz_node_results} qnr
    INNER JOIN {quiz_node_properties} qnp ON qnr.vid = qnp.vid
    WHERE (qnp.quiz_always = 1 OR (%d BETWEEN qnp.quiz_open AND qnp.quiz_close))
      AND qnr.vid = %d AND qnr.uid = %d
      AND qnr.time_end = 0";
  $rid = db_result(db_query($sql, $now, $vid, $uid));
  return (int)$rid;
}

/**
 * Insert call specific to result options.
 *
 * This is called by quiz_insert().
 *
 * @param $node
 *  The quiz node.
 */
function _quiz_insert_resultoptions($node) {
  if (!$node->resultoptions) {
    return;
  }

  foreach ($node->resultoptions as $id => $option) {
    if ($option['option_name']) {
      $option['nid'] = $node->nid;
      $option['vid'] = $node->vid;
      _quiz_insert_result_option($option);
    }
  }
}

/**
 * Insert one result option.
 *
 * @param $option
 *  The option array to insert.
 */
function _quiz_insert_result_option($option) {
  $sql = "INSERT INTO {quiz_node_result_options} (nid, vid, option_name, option_summary, option_start, option_end)
    VALUES(%d, %d, '%s', '%s', %d, %d)";
  $values = array(
    $option['nid'],
    $option['vid'],
    $option['option_name'],
    $option['option_summary'],
    $option['option_start'],
    $option['option_end'],
  );
  db_query($sql, $values);
}

/**
 * Modify result of option-specific updates.
 *
 * @param $node
 *  The quiz node.
 */
function _quiz_update_resultoptions($node) {
  $sql = 'DELETE FROM {quiz_node_result_options}
          WHERE vid = %d';
  db_query($sql, $node->vid);
  _quiz_insert_resultoptions($node);
}

/**
 * Get the summary message for a completed quiz.
 *
 * Summary is determined by whether we are using the
 * pass / fail options, how the user did, and
 * whether this is being called from admin/quiz/[quizid]/view.
 *
 * TODO: Need better feedback for when a user is viewing
 * their quiz results from the results list (and possibily
 * when revisiting a quiz they can't take again).
 *
 * @param $quiz
 *  The quiz node object.
 * @param $score
 *  The score information as returned by quiz_calculate_score().
 * @return
 *  Filtered summary text or null if we are not displaying any summary.
 */
function _quiz_get_summary_text($quiz, $score) {
  $summary = array();
  
  $admin = (arg(0) == 'admin');
  if (!$admin) {
    if (!empty($score['result_option'])) {
      // Unscored quiz, return the proper result option.
      $summary['result'] = check_markup($score['result_option'], $quiz->format, FALSE);
    }
    else {
       $summary['result'] = check_markup(_quiz_pick_result_option($quiz->nid, $quiz->vid, $score['percentage_score']), $quiz->format, FALSE);
    }
  }
  
  // If we are using pass/fail, and they passed.
  if ($quiz->pass_rate > 0 && $score['percentage_score'] >= $quiz->pass_rate) {
    // If we are coming from the admin view page.
    if ($admin) {
      $summary['passfail'] = t('The user passed this quiz.');
    }
    elseif (trim($quiz->summary_pass) != '') {
      $summary['passfail'] = check_markup($quiz->summary_pass, $quiz->format, FALSE);
    }
  }
  // If the user did not pass or we are not using pass/fail.
  else {
    // If we are coming from the admin view page,
    // only show a summary if we are using pass/fail.
    if ($admin) {
      if ($quiz->pass_rate > 0) {
        $summary['passfail'] = t('The user failed this quiz.');
      }
      else {
        $summary['passfail'] = t('the user completed this quiz.');
      }
    }
    elseif (trim($quiz->summary_default) != '') {
      $summary['passfail'] = check_markup($quiz->summary_default, $quiz->format, FALSE);
    }
  }
  return $summary;
}

/**
 * Get summary text for a particular score from a set of result options.
 *
 * @param $qnid
 *  The quiz node id.
 * @param $qvid
 *  The quiz node revision id.
 * @param $score
 *  The user's final score.
 * @return
 *  Summary text for the user's score.
 */
function _quiz_pick_result_option($qnid, $qvid, $score) {
  return db_result(db_query('SELECT option_summary FROM {quiz_node_result_options} WHERE nid = %d AND vid = %d AND %d BETWEEN option_start AND option_end', $qnid, $qvid, $score));
}

function _quiz_get_random_questions(/*$num_random, $tid*/ $quiz) {

  if (!is_object($quiz)) {
    drupal_set_message(t('The question pool cannot be generated.'), 'error');
    watchdog('quiz', '_quiz_get_random_questions was called incorrectly.', array(), WATCHDOG_ERROR);
    return FALSE;
  }
  $num_random = $quiz->number_of_random_questions;
  $tid = $quiz->tid;

  $questions = array();
  if ($num_random > 0) {
    if ($tid > 0) {
      $questions = _quiz_get_random_taxonomy_question_ids($tid, $num_random);
      /*
      // Select random questions by taxonomy.
      $term = taxonomy_get_term($tid);
      $tree = taxonomy_get_tree($term->vid, $term->tid);

      // Flatten the taxonomy tree, and just keep term id's.
      $term_ids[] = $term->tid;
      if (is_array($tree)) {
        foreach ($tree as $term) {
          $term_ids[] = $term->tid;
        }
      }
      $term_ids = implode(',', $term_ids);

      // Get all published questions with one of the allowed term ids.
      $result = db_query_range("SELECT n.nid, n.vid
        FROM {node} n
        INNER JOIN {term_node} tn USING (nid)
        WHERE n.status = 1 AND tn.tid IN ($term_ids)
        AND n.type IN ('"
        . implode("','", _quiz_get_question_types())
        . "') ORDER BY RAND()", 0, $num_random);
      */
    }
    else {
      // Select random question from assigned pool.
      $result = db_query_range("SELECT child_nid as nid, child_vid as vid FROM {quiz_node_relationship} WHERE parent_vid = %d AND parent_nid = %d AND question_status = %d ORDER BY RAND()", $quiz->vid, $quiz->nid, QUESTION_RANDOM, 0, $quiz->number_of_random_questions);
      while ($question_node = db_fetch_array($result)) {
        $questions[] = $question_node;
      }
    }
  }
  return $questions;
}


/**
 * Given a term ID, get all of the question nid/vids that have that ID.
 * @param $tid
 *  Integer term ID.
 * @return
 *  Array of nid/vid combos, like array(array('nid'=>1, 'vid'=>2)).
 */
function _quiz_get_random_taxonomy_question_ids($tid, $num_random) {
  if ($tid == 0) {
    return array();
  }

  // Select random questions by taxonomy.
  $term = taxonomy_get_term($tid);
  $tree = taxonomy_get_tree($term->vid, $term->tid);

  // Flatten the taxonomy tree, and just keep term id's.
  $term_ids[] = $term->tid;
  if (is_array($tree)) {
    foreach ($tree as $term) {
      $term_ids[] = $term->tid;
    }
  }
  $term_ids = implode(',', $term_ids);

  // Get all published questions with one of the allowed term ids.
  $result = db_query_range("SELECT n.nid, n.vid
    FROM {node} n
    INNER JOIN {term_node} tn USING (nid)
    WHERE n.status = 1 AND tn.tid IN ($term_ids)
    AND n.type IN ('"
    . implode("','", array_keys(_quiz_get_question_types()))
    . "') ORDER BY RAND()", 0, $num_random);

  $questions = array();
  while ($question_node = db_fetch_array($result)) {
    $questions[] = $question_node;
  }

  return $questions;
}

/**
 * Retrieve list of question types.
 *
 * @return
 *  Array of question types.
 */
function _quiz_get_question_types() {
  static $to_return = array();
  if (!empty($to_return)) 
    return $to_return;
  $to_return = module_invoke_all('quiz_question_info');
  $types = array();
  $placeholders = array();
  foreach ($to_return as $key => $value) {
    $placeholders[] = "'%s'";
    $types[] = $key;
  }
  $sql = 'SELECT type, name, description
          FROM {node_type}
          WHERE type IN ('.implode(',', $placeholders).')';
  $res = db_query($sql, $types);
  while ($res_o = db_fetch_object($res)) {
    $to_return[$res_o->type]['name'] = check_plain($res_o->name);
    $to_return[$res_o->type]['description'] = check_markup($res_o->description);
  }
  return $to_return;
}

/**
 * Retrieve list of vocabularies for all quiz question types.
 *
 * @return
 *  An array containing a vocabulary list.
 */
function _quiz_get_vocabularies() {
  $vocabularies = array();
  $types = array_keys(_quiz_get_question_types());
  foreach ($types as $type) {
    foreach (taxonomy_get_vocabularies($type) as $vid => $vocabulary) {
      $vocabularies[$vid] = $vocabulary;
    }
  }
  return $vocabularies;
}

/**
 * Prints a taxonomy selection form for each vocabulary.
 *
 * @param $value
 *  Default selected value(s).
 * @return
 *  HTML output to print to screen.
 */
function _quiz_taxonomy_select($value = 0) {
  $options = array();
  foreach (_quiz_get_vocabularies() as $vid => $vocabulary) {
    $temp = taxonomy_form($vid, $value);
    $options = array_merge($options, $temp['#options']);
  }
  return $options;
}

/**
 * Retrieve list of published questions assigned to quiz.
 *
 * @return
 *  An array of questions.
 */
function _quiz_get_questions($quiz_nid = NULL, $quiz_vid = NULL, $include_all_types = TRUE, $nid_keys = FALSE, $include_question = TRUE) {
  $filter_types = '';
  $questions    = array();
  $where_add    = array();
  $where_sql    = '';

  if ($include_all_types === TRUE) {
    $types = array_keys(_quiz_get_question_types());
    if (count($types) > 0) {
    $str_types = "'". implode("','", $types) ."'";
      $where_add[] = 'question.type IN ('. $str_types .')';
    }
  }

  if (!is_null($quiz_vid)) {
    $where_add[] = 'qnr.parent_vid = '. intval($quiz_vid);
    $where_add[] = 'qnr.parent_nid = '. intval($quiz_nid);
  }

  // Only include published questions.
  $where_add[] = 'question.status = 1';

  if (count($where_add)) {
    $where_sql = ' WHERE ';

    foreach ($where_add as $where) {
      $where_sql .= $where .' AND ';
    }

    $where_sql = trim( $where_sql, ' AND ');
  }

  $result = db_query('SELECT question.nid, nr.vid, question.vid AS latest_vid, question.type, nr.title, nr.body, nr.format, qnr.question_status, qnr.weight, qnr.max_score
    FROM {node} question
    INNER JOIN {node_revisions} nr ON question.nid = nr.nid
    LEFT JOIN {quiz_node_relationship} qnr ON nr.vid = qnr.child_vid
      AND qnr.parent_vid = %d
      AND qnr.question_status != %d
    '. $where_sql . ' ORDER BY weight', $quiz_vid, QUESTION_NEVER
  );

  // Create questions array.
  if ($nid_keys === FALSE) {
    while ($node = db_fetch_object($result)) {
      $questions[] = quiz_node_map($node, $include_question);
    }
  }
  else {
    while ($node = db_fetch_object($result)) {
      $n = quiz_node_map($node);
      $questions[$n->nid] = $n;
    }
  }
  return $questions;
}


/**
 * Retrieve list of published questions not assigned to quiz.
 *
 * @access public
 * @param integer $quiz_nid
 * @return array
 *  Array of questions objects.
 */
// FIXME this isn't called anywhere.  do we need it?
// (it's also horribly inefficient)
/*
function _quiz_get_unused_questions($quiz_vid = NULL, $nid_keys = FALSE) {
  $quiz       = menu_get_object();
  $types      = array_keys(_quiz_get_question_types());
  $where_sql  = '';
  $questions = array();

  if (count($types) > 0) {
    $where_sql = "AND question.type IN ('". implode("','", $types) ."')";
  }

  $result = db_query('SELECT question.nid, question.vid, question.type, nr.body, nr.format
    FROM {node} question
    LEFT JOIN {node_revisions} nr ON (question.nid = nr.nid)
    WHERE question.status = 1
    AND (question.vid NOT IN
      (SELECT DISTINCT qnr.child_vid
      FROM {quiz_node_relationship} qnr
      WHERE qnr.parent_vid = %d
      AND qnr.question_status != '. QUESTION_NEVER .'))
    '. $where_sql, $quiz_vid
  );

  // Create questions array.
  if ($nid_keys === FALSE) {
    while ($node = db_fetch_object($result)) {
      $questions[] = quiz_node_map($node);
    }
  }
  else {
    while ($node = db_fetch_object($result)) {
      $n = quiz_node_map($node);
      $questions[$n->nid] = $n;
    }
  }
  return $questions;
}
*/



/**
 * Get a full results list.
 *
 * @param $nid
 *  Node ID for the quiz.
 * @param $uid
 *  Optional user ID to constrain results to just that user.
 * @return
 *  A list of results.
 */
function _quiz_get_results($nid = '', $uid = 0) {
  $results = array();
  $args = array();
  /* This seems to have an unnecessary join in here:
  $sql = "SELECT n.nid, n.title, u.name, qnrs.result_id, qnrs.time_start, qnrs.time_end
          FROM {node} n
          INNER JOIN {quiz_node_properties} qnp
          INNER JOIN {quiz_node_results} qnrs
          INNER JOIN {users} u
          WHERE n.type = 'quiz'
            AND n.nid = qnp.nid
            AND qnrs.nid = qnp.nid
            AND u.uid = qnrs.uid";
  */
  $sql = "SELECT n.nid, n.title, u.name, u.uid, qnrs.result_id, qnrs.score, qnrs.time_start, qnrs.time_end, qnp.pass_rate
          FROM {node} n
          INNER JOIN {quiz_node_results} qnrs ON qnrs.nid = n.nid
          INNER JOIN {users} u ON u.uid = qnrs.uid
          INNER JOIN {quiz_node_properties} qnp ON qnrs.vid = qnp.vid
          WHERE n.type = 'quiz'";
  if ($nid) {
    $sql .= " AND qnrs.nid = %d";
    $args[] = $nid;
  }
  if ($uid != 0) {
    $sql .= " AND qnrs.uid = %d";
    $args[] = $uid;
  }
  $sql .= " ORDER BY qnrs.result_id DESC";
  $dbresult = db_query($sql, $args);
  while ($line = db_fetch_array($dbresult)) {
    $results[$line['result_id']] = $line;
  }
  return $results;
}

/**
 * Get a full list of the quizzes.
 *
 * @param $uid
 *  An optional user ID. If supplied, only quizzes created by that user will be returned.
 * @return
 *  A list of all quizzes.
 */
function _quiz_get_quizzes($uid = 0) {
  $results = array();
  $args = array();
  /* Not sure what the first inner join is supposed to do here. But as a negative
   * side effect, it returns duplicates of every quiz that has multiple vids.
  $sql = "SELECT n.nid, n.title, u.name, n.created
          FROM {node} n
          INNER JOIN {quiz_node_properties} qnp
          INNER JOIN {users} u
          WHERE n.type = 'quiz'
            AND n.nid = qnp.nid
            AND u.uid = n.uid";
  */
  $sql = "SELECT n.nid, n.vid, n.title, n.uid, u.name, n.created
          FROM {node} n
          INNER JOIN {users} u
          ON u.uid = n.uid
          WHERE n.type = 'quiz'";

  if ($uid != 0) {
    $sql .= " AND n.uid = %d";
    $args[] = $uid;
  }
  $sql .= " ORDER BY n.nid DESC";
  $dbresult = db_query(db_rewrite_sql($sql), $args);
  while ($line = db_fetch_array($dbresult)) {
    $results[$line['nid']] = $line;
  }
  return $results;
}

function _quiz_get_answers($rid) {
  $questions = array();
  $ids = db_query("SELECT question_nid, question_vid, type, rs.max_score
    FROM {quiz_node_results_answers} ra
    LEFT JOIN {node} ON (question_nid = nid)
    LEFT JOIN {quiz_node_results} r ON (ra.result_id = r.result_id)
    LEFT JOIN {quiz_node_relationship} rs ON (question_vid = rs.child_vid)
    WHERE ra.result_id = %d
    AND rs.parent_vid = r.vid
    ORDER BY answer_timestamp", $rid);
  while ($line = db_fetch_object($ids)) {
    $module = quiz_question_module_for_type($line->type);
    // Invoke hook_get_report().
    $questions[$line->question_nid] = module_invoke($module, 'get_report', $line->question_nid, $line->question_vid, $rid);
    if (!isset($questions[$line->question_nid]->score_weight)) {
      if ($questions[$line->question_nid]->max_score == 0) $weight = 0;
      else $weight = $line->max_score / $questions[$line->question_nid]->max_score;
      $questions[$line->question_nid]->qnr_max_score = $line->max_score;
      $questions[$line->question_nid]->score_weight = $weight;
    }
  }
  return $questions;
}

/**
 * Get the quiz name variable and set it as a constant
 * so we don't have to keep calling it in every function.
 *
 * @return
 *  Quiz name variable.
 */
function _quiz_get_quiz_name() {
  return variable_get('quiz_name', 'Quiz');
}

/**
 * Determine quiz availability status.
 *
 * @return
 *  String representing status open, closed or future.
 */
function _quiz_availability($node) {
  $time = time();
  if ($node->quiz_always || ($node->quiz_open < $time) && ($node->quiz_close > $time)) {
    return 'open';
  }
  elseif ($node->quiz_open > $time) {
    return 'future';
  }

  return 'closed';
}

/**
 * Get an array of feedback options.
 *
 * @return
 *  An array of feedback options.
 */
function _quiz_get_feedback_options() {
  return array(
    QUIZ_FEEDBACK_END => t('At the end of the @quiz', array('@quiz' => QUIZ_NAME)),
    QUIZ_FEEDBACK_QUESTION => t('After each question'),
    QUIZ_FEEDBACK_NEVER => t('Do not show'),
  );
}



/**
 * Takes a time element and prepares to send it to form_date().
 *
 * @param $time
 *  The time to be turned into an array. This can be:
 *   - A timestamp when from the database.
 *   - An array (day, month, year) when previewing.
 *   - NULL for new nodes.
 * @return
 *  An array for form_date (day, month, year).
 */
function _quiz_form_prepare_date($time = '', $offset = 0) {
  // If this is empty, get the current time.
  if ($time == '') {
    $time = time();
    $time = strtotime("+$offset days", $time);
  }
  // If we are previewing, $time will be an array so just pass it through...
  $time_array = array();
  if (is_array($time)) {
    $time_array = $time;
  }
  // ...otherwise build the array from the timestamp.
  elseif (is_numeric($time)) {
    $time_array = array(
      'day' => _quiz_date('j', $time),
      'month' => _quiz_date('n', $time),
      'year' => _quiz_date('Y', $time),
    );
  }
  return $time_array;
}

/**
 * This function was copied from the triggers module as to prevent having to be dependent
 * on that module for the actions to work.  The trigger function is called trigger_options()
 *
 * @param $type
 *   One of 'node', 'user', 'comment'.
 * @return
 *   Array keyed by action ID.
 */
function quiz_action_options($type = 'all') {
  $options = array(t('Choose an action'));
  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {
    $options[$action['type']][$aid] = $action['description'];
  }

  if ($type == 'all') {
    return $options;
  }
  else {
    $options[$type][0] = t('Choose an action');
    // Lets sort it to get the choose an action back first.
    ksort($options[$type]);
    return $options[$type];
  }
}

/*
 * Implementation of hook_cron()
 */

function quiz_cron() {
  $rm_time = variable_get('quiz_remove_partial_quiz_record', '0');
  if ($rm_time) { // $time = 0 for never
    db_query('DELETE FROM {quiz_node_results} WHERE !time_end AND (%d - time_start) > %d', time(), $rm_time);
  }
}

/**
 * @return array
 *  options suitable for a form, in which the value is nid
 */
function quiz_get_quiz_options() {
  $options = array();
  // FIXME use the names set by the user config
  $results = db_query(db_rewrite_sql("SELECT n.nid, n.title, n.type FROM {node} n WHERE n.type = 'quiz'"));
  while ($result = db_fetch_object($results)) {
    $options[$result->nid] = substr(check_plain($result->title), 0, 30);
    // truncate the node title if its length is greater than 30 characters
  }
  return $options;
}

/**
 * Tells whether a question node is being viewed inside/outside of quiz.
 * @return
 *   boolean
 */
function _quiz_is_taking_context() {
  return arg(2) == 'take';
  /*
  $display_object = menu_get_object('quiz_type_access');
  // display_object is empty for question views because 'quiz_type_access' doesn't load them
  if ($display_object->type == 'quiz') {
    return TRUE;
  }
  return FALSE;*/
}

/**
 * Makes, saves and returns a new quiz node.
 *
 * @param $title - the title of the new node
 * @return $node
 */
function quiz_make_new($title) {
  global $user;
  $new_node = new stdClass();
  $new_node->title = $title;
  $new_node->type = 'quiz';
  $new_node->status = 1;
  $new_node->quiz_open = _quiz_form_prepare_date();
  $new_node->quiz_close = _quiz_form_prepare_date(NULL, variable_get('quiz_default_close', 30));
  $new_node->auto_created = true;
  $new_node->uid = $user->uid;
  node_save($new_node);
  if (is_numeric($new_node->nid)) {
    drupal_set_message(t('Quiz %title has been created.', array('%title' => $title)));
  }
  return $new_node;
}

function quiz_get_quiz_from_menu() {
  if ($to_return = menu_get_object('quiz_type_access'))
    return $to_return;
  return menu_get_object('quiz_type_access', 4);
}

/**
 * Finds out if a quiz has been answered or not...
 *
 * @return
 *   true if there exists answers to the current question
 */
function quiz_has_been_answered($node) {
  if (!isset($node->nid)) return false;
  $sql = 'SELECT *
          FROM {quiz_node_results}
          WHERE nid = %d AND vid = %d
          LIMIT 1';
  $res = db_query($sql, $node->nid, $node->vid);
  return db_fetch_object($res) ? TRUE : FALSE;
}

/**
 * If a quiz is saved as not randomized we should make sure all random questions are converted to always...
 *
 * @param $node
 *   quiz node
 */
function _quiz_check_num_random(&$node) {
  if ($node->randomization > 0) return;
  $node->number_of_random_questions = 0;
  $sql = 'UPDATE {quiz_node_relationship}
          SET question_status = %d
          WHERE parent_nid = %d AND parent_vid = %d';
  db_query($sql, QUESTION_ALWAYS, $node->nid, $node->vid);
}

/**
 * Determine who should have access to the My results tab.
 */
function _quiz_user_results_access($user_id) {
  global $user;
  return ($user_id == $user->uid && user_access('view own quiz results')) || user_access('view any quiz results');
}

/**
 * Copies questions when a quiz is translated
 * 
 * @param $node
 *   The new translated quiz node
 */
function quiz_copy_questions($node) {
  // Find original questions:
  $sql = 'SELECT child_nid, child_vid, question_status, weight, max_score
          FROM {quiz_node_relationship}
          WHERE parent_vid = %d';
  $res = db_query($sql, $node->translation_source->vid);
  while ($res_o = db_fetch_object($res)) {
    $original_question = node_load($res_o->child_nid);
    
    // Unset variables we can't or won't carry with us to the translated node...
    $original_question->nid = $original_question->vid = $original_question->created = $original_question->changed = NULL;
    $original_question->revision_timestamp = $original_question->menu = $original_question->path = NULL;
    $original_question->files = array();
    if (isset($original_question->book['mlid']))
      $original_question->book['mlid'] = NULL;
    
    // Set the correct language
    $original_question->language = $node->language;
    
    // Save the node
    node_save($original_question);    
    
    // Save the relationship between the new question and the quiz...
    $sql = 'INSERT INTO {quiz_node_relationship}
            (parent_nid, parent_vid, child_nid, child_vid, question_status, weight, max_score)
            VALUES(%d, %d, %d, %d, %d, %d, %d)';
    db_query($sql, $node->nid, $node->vid, $original_question->nid, $original_question->vid, $res_o->question_status, $res_o->weight, $res_o->max_score);
  }
}

function _quiz_maintain_results($quiz, $rid) {
  global $user;
  
  // Do not delete results for anonymous users
  if ($user->uid == 0) return; 
  
  switch ($quiz->keep_results) {
    case QUIZ_KEEP_ALL:
      return;
    case QUIZ_KEEP_BEST: //I'm afraid of what this query might do to performance...
      $sql = 'SELECT result_id 
              FROM {quiz_node_results}
              WHERE nid = %d AND uid = %d AND is_evaluated = 1 AND result_id != (
                SELECT result_id
                FROM {quiz_node_results}
                WHERE score = (
                  SELECT MAX(score)
                  FROM {quiz_node_results}
                  WHERE nid = %d AND uid = %d
                )
                AND nid = %d AND uid = %d LIMIT 1
              )';
      $res = db_query($sql, $quiz->nid, $user->uid, $quiz->nid, $user->uid, $quiz->nid, $user-uid);
      $rids = array();
      while ($rid2 = db_result($res)) {
        $rids[] = $rid2;
      }
      quiz_delete_results($rids);
      break;
    case QUIZ_KEEP_LATEST:
      $sql = 'SELECT result_id
              FROM {quiz_node_results}
              WHERE nid = %d AND uid = %d AND is_evaluated = 1 AND result_id != %d';
      $res = db_query($sql, $quiz->nid, $user->uid, $rid);
      $rids = array();
      while ($rid2 = db_result($res)) {
        $rids[] = $rid2;
      }
      quiz_delete_results($rids);
      break;
  }
}

function quiz_delete_results($rids) {
  //security:
  foreach ($rids as $key => $value) {
    $rids[$key] = intval($value);
  }
  if (empty($rids))
    return;
  $sql = 'SELECT result_id, question_nid, question_vid
          FROM {quiz_node_results_answers}
          WHERE result_id IN('. implode(', ', $rids) .')';
  $res = db_query($sql);
  while ($res_o = db_fetch_object($res)) {
    quiz_question_delete_result($res_o->result_id, $res_o->question_nid, $res_o->question_vid);
    db_query('DELETE FROM {quiz_node_results_answers} WHERE result_id = %d', $res_o->result_id);
    db_query('DELETE FROM {quiz_node_results} WHERE result_id = %d', $res_o->result_id);
  }
}

function _quiz_load_user_settings(&$node) {
  global $user;
  $sql = "SELECT * FROM {quiz_user_settings} WHERE uid = %d";
  $res = db_query($sql, isset($node->def_uid) ? $node->def_uid : $user->uid);
  if ($res_o = db_fetch_object($res)) {
    foreach ($res_o as $key => $value) {
      if (!in_array($key, array('nid', 'vid', 'uid')))
        $node->{$key} = $value;
    }
    $result_options = db_query('SELECT * FROM {quiz_node_result_options} WHERE nid = %d AND vid= %d', $res_o->nid, $res_o->vid);
    while ($option = db_fetch_array($result_options)) {
      $node->resultoptions[] = $option;
    }
    return TRUE;
  }
  return FALSE;
}

function _quiz_save_user_settings($node) {
  global $user;
  if ($node->auto_created)
    return FALSE;
  $sql = 'SELECT uid FROM {quiz_user_settings} WHERE uid = %d';
  $res = db_query($sql, is_array($node) ? (isset($node['save_def_uid']) ? $node['save_def_uid'] : $user->uid) : $user->uid);
  $update = is_numeric(db_result($res)) ? array('uid') : array();
  if (isset($node->save_def_uid))
    $node['uid'] = $node['save_def_uid'];
  drupal_write_record('quiz_user_settings', $node, $update);
}
function _quiz_redirect_if_empty($node) {
  $sql = 'SELECT child_vid 
          FROM {quiz_node_relationship}
          WHERE parent_vid = %d';
  $res = db_query($sql, $node->vid);
  if (!$res_o = db_fetch_object($res))
    $_REQUEST['destination'] = url("node/$node->nid/questions");
}

function _quiz_get_num_always_questions($nid, $vid) {
  $sql = 'SELECT count(*) 
          FROM {quiz_node_relationship}
          WHERE parent_vid = %d AND question_status = %d';
  return db_result(db_query($sql, $vid, QUESTION_ALWAYS));
}