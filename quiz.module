<?php

/**
 * @file
 * Quiz Module
 *
 * This module allows the creation of interactive quizzes for site visitors.
 */
// This module is structured as follows:
//
// The main module file:
// * Defines and general includes are at the top.
// * Hook implementations come immediately after.
// * Public functions come next.
// * Private functions are at the bottom.
//
// Where possible, user pages are located in quiz.pages.inc, and admin pages
// are in quiz.admin.inc. Most utility functions have been left here, even if they
// are only used by a function in one of the other files.
//
// Themes are in quiz.pages.inc unless they clearly only apply to admin screens.
// Then they are in quiz.admin.inc.
//
// Views support is included in includes/views/quiz.views.inc
define('QUIZ_VIEWS_DIR', drupal_get_path('module', 'quiz') . '/includes/views');

/*
 * Define question statuses...
 */
define('QUESTION_RANDOM', 0);
define('QUESTION_ALWAYS', 1);
define('QUESTION_NEVER', 2);

/**
 * Quiz name.
 */
define('QUIZ_NAME', _quiz_get_quiz_name());

/**
 * Define options for keeping results.
 */
define('QUIZ_KEEP_BEST', 0);
define('QUIZ_KEEP_LATEST', 1);
define('QUIZ_KEEP_ALL', 2);

/**
 * Implements hook_help().
 */
function quiz_help($path, $arg) {
  // This is moved on an experimental basis.
  include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'quiz') . '/quiz.help.inc';
  return _quiz_help($path, $arg);
}

/**
 * Implements hook_views_api().
 */
function quiz_views_api() {
  return array(
    'api' => '3.0',
    'path' => QUIZ_VIEWS_DIR,
  );
}

/**
 * Implements hook_ctools_plugin_directory() to let the system know
 * where our task and task_handler plugins are.
 */
function quiz_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'page_manager') {
    return 'plugins/page_manager/' . $plugin_type;
  }
  if ($owner == 'ctools' && $plugin_type == 'content_types') {
    return 'plugins/content_types';
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function quiz_ctools_plugin_api($module, $api) {

  if ($module == 'page_manager' && $api == 'pages_default') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function quiz_entity_info_alter(&$info) {
  // Add a new view mode for displaying the question when taking a quiz
  $info['node']['view modes'] += array(
    'question' => array(
      'label' => t('Question'),
      'custom settings' => TRUE,
    ),
  );
}

/**
 * Implements hook_permission().
 */
function quiz_permission() {
  return array(
    // Configure quiz:
    'administer quiz configuration' => array(
      'title' => t('Administer quiz configuration'),
      'description' => t('Control the various settings and behaviours of quiz'),
      'restrict access' => TRUE,
    ),
    // Managing quizzes:
    'access quiz' => array(
      'title' => t('Take quiz'),
      'description' => t('Can access (take) all quizzes.'),
    ),
    // viewing results:
    'view any quiz results' => array(
      'title' => t('View any quiz results'),
      'description' => t('Can view results for all quizzes and users.'),
    ),
    'view own quiz results' => array(
      'title' => t('View own quiz results'),
      'description' => t('Quiz takers can view their own results, also when quiz is not passed.'),
    ),
    'view results for own quiz' => array(
      'title' => t('View results for own quiz'),
      'description' => t('Quiz makers can view results for their own quizzes.'),
    ),
    // deleting results:
    'delete any quiz results' => array(
      'title' => t('Delete any quiz results'),
    ),
    'delete results for own quiz' => array(
      'title' => t('Delete own quiz results'),
    ),
    // scoring:
    'score any quiz' => array(
      'title' => t('Score any quiz'),
    ),
    'score own quiz' => array(
      'title' => t('Score own quiz'),
    ),
    'score taken quiz answer' => array(
      'title' => t('score taken quiz answer'),
      'description' => t('Allows attendee to score questions needing manual evaluation.'),
    ),
    // Allow a quiz question to be viewed outside of a test.
    'view quiz question outside of a quiz' => array(
      'title' => t('View quiz question outside of a quiz'),
      'description' => t('Questions can only be accessed through taking a quiz (not as individual nodes) unless this permission is given.'),
    ),
    // Allow the user to see the correct answer, when viewed outside a quiz
    'view any quiz question correct response' => array(
      'title' => t('View any quiz question correct response'),
      'description' => t('Allow the user to see the correct answer, when viewed outside a quiz.'),
    ),
    // Allows users to pick a name for their questions. Otherwise this is auto
    // generated.
    'edit question titles' => array(
      'title' => t('Edit question titles'),
      'description' => t('Questions automatically get a title based on the question text. This allows titles to be set manually.'),
    ),
    // Control revisioning, only assign this permission to users who understand
    // who permissions work. Note: If a quiz or question is changed and not
    // revisioned you will also change existing result reports.
    'manual quiz revisioning' => array(
      'title' => t('Manual quiz revisioning'),
      'description' => t('Quizzes are revisioned automatically each time they are changed. This allows you to do revisions manually.'),
    ),
  );
}

/**
 * Implements hook_admin_paths().
 */
function quiz_admin_paths() {
  return array(
    'node/*/quiz' => TRUE,
    'node/*/quiz/*' => TRUE,
  );
}

/**
 * Helper function to determine if a user has access to the different results
 * pages.
 *
 * @param $quiz
 *   The quiz node.
 * @param $result_id
 *   The result id of a result we are trying to access.
 * @return boolean
 *   TRUE if user has permission.
 */
function quiz_access_results($quiz, $result_id = NULL) {
  global $user;

  if ($quiz->type !== 'quiz') {
    return FALSE;
  }
  // If rid is set we must make sure the result belongs to the quiz we are
  // viewing results for.
  if (isset($result_id)) {
    $res = db_query('SELECT qnr.nid, qnr.uid FROM {quiz_node_results} qnr WHERE result_id = :result_id', array(':result_id' => $result_id))->fetch();
    if ($res && $res->nid != $quiz->nid) {
      return FALSE;
    }
  }
  if (user_access('view any quiz results')) {
    return TRUE;
  }
  if (user_access('view results for own quiz') && $user->uid == $quiz->uid) {
    return TRUE;
  }
  if (user_access('score taken quiz answer')) {
    //check if the taken user is seeing his result
    if (isset($result_id) && $res && $res->uid == $user->uid) {
      return TRUE;
    }
  }
}

/**
 * Helper function to determine if a user has access to view his quiz results
 *
 * @param object $quiz
 *  The Quiz node
 */
function quiz_access_my_results($quiz) {
  global $user;
  if ($quiz->type !== 'quiz') {
    return FALSE;
  }

  $answered = db_query('SELECT 1 FROM {quiz_node_results} WHERE nid = :nid AND uid = :uid AND is_evaluated = :is_evaluated', array(':nid' => $quiz->nid, ':uid' => $user->uid, ':is_evaluated' => 1))->fetchField();
  if ($answered) {
    return TRUE;
  }
}

/**
 * Helper function to determine if a user has access to view a specific quiz result.
 *
 * @param int $result_id
 *  Result id
 * @return boolean
 *  True if access, false otherwise
 */
function quiz_access_my_result($result_id) {
  global $user;

  // Check if the quiz taking has been completed.
  $quiz_result = quiz_result_load($result_id);
  $node = node_load($quiz_result->nid, $quiz_result->vid);

  if (quiz_access_to_score($node->uid) || ($quiz_result->time_end > 0 && $quiz_result->uid == $user->uid)) {
    return TRUE;
  }
}

/**
 * Helper function to determine if a user has access to score a quiz.
 *
 * @param $quiz_creator
 *   uid of the quiz creator.
 */
function quiz_access_to_score($quiz_creator = NULL) {
  global $user;
  if ($quiz_creator == NULL && ($quiz = quiz_get_quiz_from_menu())) {
    $quiz_creator = $quiz->uid;
  }
  if (user_access('score any quiz')) {
    return TRUE;
  }
  if (user_access('score own quiz') && $user->uid == $quiz_creator) {
    return TRUE;
  }
  if (user_access('score taken quiz answer')) {
    return TRUE;
  }
}

/**
 * Helper function to check if the user has any of a given list of permissions.
 *
 * @param args
 *   Any number of permissions.
 * @return
 *   TRUE if the user has access to any of the arguments given.
 */
function quiz_access_multi_or() {
  $perms = func_get_args();
  foreach ($perms as $perm) {
    if (user_access($perm)) {
      return TRUE;
    }
  }
}

/**
 * Implements hook_node_info().
 */
function quiz_node_info() {
  return array(
    'quiz' => array(
      'name' => t('@quiz', array("@quiz" => QUIZ_NAME)),
      'base' => 'quiz',
      'description' => 'Create interactive quizzes for site visitors',
    )
  );
}

/**
 * Implements hook_cron().
 */
function quiz_cron() {
  // Remove old quiz results that haven't been finished.
  $rm_time = variable_get('quiz_remove_partial_quiz_record', '0');

  if ($rm_time) { // $time = 0 for never.
    db_delete('quiz_node_results')
      ->condition('time_end', 0)
      ->where('(:request_time - time_start) > :remove_time', array(
        ':request_time' => REQUEST_TIME,
        ':remove_time' => $rm_time
      ))
      ->execute();
  }
}

/**
 * Implements hook_menu().
 */
function quiz_menu() {

  // Take quiz.
  $items['node/%quiz_menu/take'] = array(
    'title' => 'Take',
    'page callback' => 'quiz_take',
    'page arguments' => array(1),
    'access callback' => 'quiz_take_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  // Take question.
  // @todo Thought - the 4th argument could be a "page" instead of a question
  // number
  $items['node/%quiz_menu/take/%question_number'] = array(
    'title' => 'Take',
    'page callback' => 'quiz_take_question',
    'page arguments' => array(1, 3),
    'access callback' => 'quiz_access_question',
    'access arguments' => array(1, 3),
  );

  // Feedback
  $items['node/%quiz_menu/take/%question_number/feedback'] = array(
    'title' => 'Feedback',
    'page callback' => 'quiz_take_question_feedback',
    'page arguments' => array(1, 3),
    'access callback' => 'quiz_question_feedback_access',
    'access arguments' => array(1, 3),
  );


  // Admin pages.
  $items['admin/quiz'] = array(
    'title' => '@quiz',
    'title arguments' => array('@quiz' => QUIZ_NAME),
    'description' => 'View results, score answers, run reports and edit configurations.',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer quiz configuration', 'score any quiz', 'score own quiz', 'view any quiz results', 'view results for own quiz'),
    'access callback' => 'quiz_access_multi_or',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['admin/quiz/settings'] = array(
    'title' => '@quiz settings',
    'title arguments' => array('@quiz' => QUIZ_NAME),
    'description' => 'Change settings for the all Quiz project modules.',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer quiz configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['admin/quiz/settings/config'] = array(
    'title' => '@quiz configuration',
    'title arguments' => array('@quiz' => QUIZ_NAME),
    'description' => 'Configure the Quiz module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quiz_admin_settings'),
    'access arguments' => array('administer quiz configuration'),
    'type' => MENU_NORMAL_ITEM, // optional
    'file' => 'quiz.admin.inc',
  );

  $items['admin/quiz/settings/quiz-form'] = array(
    'title' => '@quiz form configuration',
    'title arguments' => array('@quiz' => QUIZ_NAME),
    'description' => 'Configure default values for the quiz creation form.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('quiz_admin_node_form'),
    'access arguments' => array('administer quiz configuration'),
    'type' => MENU_NORMAL_ITEM, // optional
    'file' => 'quiz.admin.inc',
  );

  $items['admin/quiz/reports'] = array(
    'title' => '@quiz reports and scoring',
    'title arguments' => array('@quiz' => QUIZ_NAME),
    'description' => 'View reports and score answers.',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('view any quiz results', 'view results for own quiz'),
    'access callback' => 'quiz_access_multi_or',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['node/%quiz_menu/quiz-results/%quiz_rid/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['node/%quiz_menu/quiz-results/%quiz_rid'] = array(
    'title' => 'User results',
    'page callback' => 'quiz_user_results',
    'page arguments' => array(3),
    'access callback' => 'quiz_access_my_result',
    'access arguments' => array(3),
    'file' => 'quiz.pages.inc',
  );

  $items['node/%quiz_menu/quiz/results/%quiz_rid/view'] = array(
    'title' => 'Results',
    'page callback' => 'quiz_admin_results',
    'page arguments' => array(1, 4),
    'access callback' => 'quiz_access_results',
    'access arguments' => array(1, 4),
    'file' => 'quiz.admin.inc',
  );

  // Add questions to quiz.
  $items['node/%quiz_menu/quiz/questions'] = array(
    'title' => 'Manage questions',
    'page callback' => 'quiz_questions',
    'page arguments' => array(1),
    'access callback' => 'quiz_type_confirm',
    'access arguments' => array(1, 'update'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'quiz.admin.inc',
    'weight' => 2,
  );

  // User pages.

  $items['user/%/quiz-results/%/view'] = array(
    'title' => 'User results',
    'page callback' => 'quiz_user_results',
    'page arguments' => array(3),
    'access arguments' => array(3),
    'access callback' => 'quiz_access_my_result',
    'type' => MENU_CALLBACK,
    'file' => 'quiz.pages.inc',
  );

  $items['node/%quiz_menu/questions/term_ahah'] = array(//TODO: Add node access instead of user access...
    'page callback' => 'quiz_categorized_term_ahah',
    'type' => MENU_CALLBACK,
    'access callback' => 'node_access',
    'access arguments' => array('create', 'quiz'),
    'file' => 'quiz.admin.inc',
  );

  if (module_exists('devel_generate')) {
    $items['admin/config/development/generate/quiz'] = array(
      'title' => 'Generate quiz',
      'description' => 'Generate a given number of quizzes and questions.',
      'access arguments' => array('administer quiz configuration'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('quiz_generate_form'),
      'file' => 'quiz.devel.inc',
    );
  }

  return $items;
}

/**
 * Implements hook_theme().
 */
function quiz_theme($existing, $type, $theme, $path) {
  return array(
    'quiz_view_stats' => array(
      'variables' => array('node' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_categorized_form' => array(
      'render element' => 'form',
      'file' => 'quiz.admin.inc'
    ),
    'quiz_result' => array(
      'variables' => array('quiz' => NULL, 'questions' => NULL, 'score' => NULL, 'summary' => NULL, 'result_id' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_progress' => array(
      'variables' => array('question_number' => NULL, 'num_questions' => NULL, 'allow_jumping' => NULL, 'time_limit' => NULL),
      'file' => 'quiz.pages.inc',
    ),
    'quiz_no_feedback' => array(
      'file' => 'quiz.pages.inc',
      'variables' => array(),
    ),
    'question_selection_table' => array(
      'file' => 'quiz.admin.inc',
      'render element' => 'form',
    ),
    'quiz_answer_result' => array(
      'file' => 'quiz.pages.inc',
      'variables' => array(),
    ),
    'quiz_report_form' => array(
      'render element' => 'form',
      'path' => $path . '/theme',
      'template' => 'quiz-report-form',
    ),
    'quiz_node_form' => array(
      'render element' => 'form',
      'file' => 'quiz.admin.inc',
    ),
    'quiz_browser' => array(
      'render element' => 'form',
      'file' => 'quiz.admin.inc',
    ),
    'quiz_question_score' => array(
      'variables' => array('score' => NULL, 'max_score' => NULL),
      'path' => $path . '/theme',
      'template' => 'quiz-question-score',
    ),
    'quiz_pager' => array(
      'variables' => array('total' => 0, 'current' => 0, 'siblings' => 0),
    ),
  );
}

/**
 * Implements hook_form_alter().
 *
 * Override settings in some existing forms. For example, we remove the
 * preview button on a quiz.
 */
function quiz_form_alter(&$form, $form_state, $form_id) {
  // Set taking options the first vertical tab item
  if ('quiz_node_form' == $form_id && isset($form['menu']['#weight'])) {
    $form['menu']['#weight'] = 1;
  }
  // Remove revision fieldset if user don't have access to revise quiz manually.
  if (isset($form['#quiz_check_revision_access'])) {
    if (!user_access('manual quiz revisioning') || variable_get('quiz_auto_revisioning', 1)) {
      $form['revision_information']['revision']['#type'] = 'value';
      $form['revision_information']['revision']['#value'] = $form['revision_information']['revision']['#default_value'];
      $form['revision_information']['log']['#type'] = 'value';
      $form['revision_information']['log']['#value'] = $form['revision_information']['log']['#default_value'];
      $form['revision_information']['#access'] = FALSE;
    }
    unset($form['actions']['preview'], $form['actions']['preview_changes']);
    $form['actions']['submit']['#access'] = TRUE;
    // Quiz questions might want to add a cancel button.
    if (isset($form['#cancel_button'])) {
      $form['actions']['cancel'] = array(
        '#markup' => l(t('Cancel'), $form_state['redirect']),
        '#weight' => 6,
      );
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for the quiz node form.
 */
function quiz_form_quiz_node_form_alter(&$form, $form_state) {
  $form['actions']['submit']['#submit'][] = 'quiz_form_quiz_node_form_submit';
}

/**
 * Quiz node form submit callback.
 *
 * @see quiz_form_quiz_node_form_alter()
 */
function quiz_form_quiz_node_form_submit($form, &$form_state) {
  $node = $form_state['node'];

  if (empty($form_state['values']['nid'])) {
    drupal_set_message(t('You just created a new @quiz. Now you have to add questions to it. This page is for adding and managing questions. Here you can create new questions or add some of your already created questions. If you want to change the quiz settings, you can use the "edit" tab.'), array('@quiz' => QUIZ_NAME));
    $form_state['redirect'] = "node/$node->nid/quiz/questions";
  }
  // If the quiz don't have any questions jump to the manage questions tab.
  $res = db_query('SELECT child_vid FROM {quiz_node_relationship} WHERE parent_vid = :vid', array(':vid' => $node->vid))->fetchField();
  if (!is_numeric($res)) {
    $form_state['redirect'] = 'node/' . $node->nid . '/quiz/questions';
  }
}

/**
 * Implements hook_insert().
 */
function quiz_insert($node) {
  global $user;

  // Need to set max_score if this is a cloned node
  $max_score = 0;

  // Copy all the questions belonging to the quiz if this is a new translation.
  if ($node->is_new && isset($node->translation_source)) {
    quiz_copy_questions($node);
  }

  // Add references to all the questions belonging to the quiz if this is a cloned quiz (node_clone compatibility)
  if ($node->is_new && isset($node->clone_from_original_nid)) {
    $old_quiz = node_load($node->clone_from_original_nid, NULL, TRUE);

    $max_score = $old_quiz->max_score;

    $questions = quiz_get_questions($old_quiz->nid, $old_quiz->vid);

    // Format the current questions for referencing
    foreach ($questions as $question) {
      $nid = $questions['nid'];
      $questions[$nid]->state = $question->question_status;
      $questions[$nid]->refresh = 0;
    }

    quiz_set_questions($node, $questions);
  }

  _quiz_common_presave_actions($node);

  // If the quiz is saved as not randomized we have to make sure that questions belonging to the quiz are saved as not random
  _quiz_check_num_random($node);
  _quiz_check_num_always($node);

  quiz_update_defaults($node);
  _quiz_insert_resultoptions($node);
}

function quiz_update_defaults($node) {
  global $user;

  $entity = clone $node;
  $entity->aid = !empty($entity->aid) ? $entity->aid : 0;
  $entity->summary_pass = is_array($node->summary_pass) ? $node->summary_pass['value'] : $node->summary_pass;
  $entity->summary_pass_format = is_array($node->summary_pass) ? $node->summary_pass['format'] : $node->summary_pass_format;
  $entity->summary_default = is_array($node->summary_default) ? $node->summary_default['value'] : $node->summary_default;
  $entity->summary_default_format = is_array($node->summary_default) ? $node->summary_default['format'] : $node->summary_default_format;
  $entity->tid = (isset($entity->tid) ? $entity->tid : 0);

  // Save the node values.
  $quiz_props = clone $entity;
  $quiz_props->uid = 0;
  quiz_save_properties($quiz_props);

  if (!empty($node->remember_settings)) {
    // Save user defaults.
    $user_defaults = clone $quiz_props;
    $user_defaults->nid = 0;
    $user_defaults->vid = 0;
    $user_defaults->uid = $user->uid;
    quiz_save_properties($user_defaults);
  }

  if (!empty($node->remember_global)) {
    // Save global defaults.
    $global_defaults = clone $quiz_props;
    $global_defaults->uid = 0;
    $global_defaults->nid = 0;
    $global_defaults->vid = 0;
    quiz_save_properties($global_defaults);
  }
}

/**
 * Insert or update the quiz node properties accordingly.
 */
function quiz_save_properties($entity) {
  $sql = "SELECT qnp_id FROM {quiz_node_properties}
    WHERE (nid = :nid AND nid > 0 AND vid = :vid AND vid > 0)
    OR (uid = :uid and uid > 0)
    OR (nid = :nid and uid = :uid and vid = :vid)";
  $result = db_query($sql, array(':nid' => $entity->nid, ':uid' => $entity->uid, ':vid' => $entity->vid));
  $entity->qnp_id = $result->fetchField();
  entity_save('quiz_properties', $entity);
}

/**
 * Implements hook_update().
 */
function quiz_update($node) {
  // Quiz node vid (revision) was updated.
  if (isset($node->revision) && $node->revision) {
    // Create new quiz-question relation entries in the quiz_node_relationship
    // table.
    quiz_update_quiz_question_relationship($node->old_vid, $node->vid, $node->nid);
  }

  // Update an existing row in the quiz_node_properties table.
  _quiz_common_presave_actions($node);

  quiz_update_defaults($node);
  _quiz_update_resultoptions($node);

  _quiz_check_num_random($node);
  _quiz_check_num_always($node);
  quiz_update_max_score_properties(array($node->vid));
  drupal_set_message(t('Some of the updated settings may not apply to quiz being taken already. To see all changes in action you need to start again.'), 'warning');
}

/**
 * Implements hook_field_extra_fields().
 */
function quiz_field_extra_fields() {
  $extra['node']['quiz'] = array(
    'display' => array(
      'take' => array(
        'label' => t('Take @quiz button', array('@quiz' => QUIZ_NAME)),
        'description' => t('The take button.'),
        'weight' => 10,
      ),
      'stats' => array(
        'label' => t('@quiz summary', array('@quiz' => QUIZ_NAME)),
        'description' => t('@quiz summary', array('@quiz' => QUIZ_NAME)),
        'weight' => 9,
      ),
    ),
    'form' => array(
      'taking' => array(
        'label' => t('Taking options'),
        'description' => t('Fieldset for customizing how a @quiz is taken', array('@quiz' => QUIZ_NAME)),
        'weight' => 0,
      ),
      'quiz_availability' => array(
        'label' => t('Availability options'),
        'description' => t('Fieldset for customizing when a @quiz is available', array('@quiz' => QUIZ_NAME)),
        'weight' => 0,
      ),
      'summaryoptions' => array(
        'label' => t('Summary options'),
        'description' => t('Fieldset for customizing summaries in the @quiz reports', array('@quiz' => QUIZ_NAME)),
        'weight' => 0,
      ),
      'resultoptions' => array(
        'label' => t('Result options'),
        'description' => t('Fieldset for customizing result comments in @quiz reports', array('@quiz' => QUIZ_NAME)),
        'weight' => 0,
      ),
      'remember_settings' => array(
        'label' => t('Remember settings'),
        'description' => t('Checkbox for remembering @quiz settings', array('@quiz' => QUIZ_NAME)),
        'weight' => 0,
      ),
      'remember_global' => array(
        'label' => t('Remember as global'),
        'description' => t('Checkbox for remembering @quiz settings', array('@quiz' => QUIZ_NAME)),
        'weight' => 0,
      ),
    ),
  );
  return $extra;
}

/**
 * Common actions that need to be done before a quiz is inserted or updated
 *
 * @param $node
 *   Quiz node
 */
function _quiz_common_presave_actions(&$node) {
  quiz_translate_form_date($node, 'quiz_open');
  quiz_translate_form_date($node, 'quiz_close');

  if (empty($node->pass_rate)) {
    $node->pass_rate = 0;
  }
  if ($node->randomization < 2) {
    $node->number_of_random_questions = 0;
  }
}

/**
 * Implements hook_delete().
 */
function quiz_delete($node) {
  $res = db_query('SELECT result_id FROM {quiz_node_results}
          WHERE nid = :nid', array(':nid' => $node->nid));
  $result_ids = array();
  while ($result_id = $res->fetchField()) {
    $result_ids[] = $result_id;
  }
  entity_delete_multiple('quiz_result', $result_ids);

  // Remove quiz node records from table quiz_node_properties
  db_delete('quiz_node_properties')
    ->condition('nid', $node->nid)
    ->execute();
  // Remove quiz node records from table quiz_node_relationship
  db_delete('quiz_node_relationship')
    ->condition('parent_nid', $node->nid)
    ->execute();
  // Remove quiz node records from table quiz_node_results
  db_delete('quiz_node_results')
    ->condition('nid', $node->nid)
    ->execute();
  // Remove quiz node records from table quiz_node_result_options
  db_delete('quiz_node_result_options')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Returns default values for all quiz settings.
 *
 * @todo also store this in the quiz_node_properties table
 *
 * @return
 *   Array of default values.
 */
function _quiz_get_node_defaults() {
  return (object) array(
      'aid' => NULL,
      'allow_jumping' => 0,
      'allow_resume' => 1,
      'allow_skipping' => 1,
      'allow_change' => 1,
      'always_available' => TRUE,
      'backwards_navigation' => 1,
      'has_userpoints' => 0,
      'keep_results' => 2,
      'mark_doubtful' => 0,
      'max_score' => 0,
      'max_score_for_random' => 1,
      'number_of_random_questions' => 0,
      'pass_rate' => 75,
      'quiz_always' => 1,
      'quiz_close' => 0,
      'quiz_open' => 0,
      'randomization' => 0,
      'repeat_until_correct' => 0,
      'review_options' => array('question' => array(), 'end' => array()),
      'show_attempt_stats' => 1,
      'show_passed' => 1,
      'summary_default' => '',
      'summary_default_format' => filter_fallback_format(),
      'summary_pass' => '',
      'summary_pass_format' => filter_fallback_format(),
      'takes' => 0,
      'tid' => 0,
      'time_limit' => 0,
      'userpoints_tid' => 0,
  );
}

/**
 * Result_id, menu argument loader.
 */
function quiz_rid_load($result_id) {
  if ($result_id > 0) {
    return $result_id;
  }
  else {
    return FALSE;
  }
}

/**
 * Workaround for a _menu_translate() bug.
 */
function quiz_rid_to_arg($result_id) {
  return quiz_rid_load($result_id);
}

/**
 * Menu loader callback. Load a quiz node if the given node ID is a quiz.
 */
function quiz_menu_load($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }
  $node = node_load($nid);
  if (!isset($node->type) || $node->type != 'quiz') {
    return FALSE;
  }
  return $node;
}

/**
 * Implements hook_load().
 *
 * Load up quiz properties onto quiz nodes.
 */
function quiz_load($nodes) {
  foreach ($nodes as $node) {
    $vids[] = $node->vid;
  }

  $quiz_properties = entity_load('quiz_properties', FALSE, array('vid' => $vids));

  foreach ($quiz_properties as $qnp_id => $props) {
    foreach ($props as $name => $value) {
      if (!in_array($name, array('uid', 'nid', 'vid'))) {
        $nodes[$props->nid]->$name = $value;
      }
    }
  }

  // Fetching result options.
  $query = db_select('quiz_node_result_options', 'qnro');
  $query->fields('qnro');
  $query->condition('vid', $vids);
  $options = $query->execute();
  foreach ($options as $option) {
    $nodes[$option->nid]->resultoptions[$option->option_id] = (array) $option;
  }
}

/**
 * Implements hook_view().
 */
function quiz_view($node, $view_mode) {
  drupal_alter('quiz_view', $node, $view_mode);
  node_invoke($node, 'prepare');

  // Number of questions is needed on the statistics page.
  $node->number_of_questions = $node->number_of_random_questions + _quiz_get_num_always_questions($node->vid);

  $node->content['stats'] = array(
    '#markup' => theme('quiz_view_stats', array('node' => $node)),
    '#weight' => -1,
  );

  $available = quiz_availability($node);
  if ($available === TRUE) {
    // Check the permission before displaying start button.
    if (user_access('access quiz')) {
      // Add a link to the take tab as a button if this isn't a teaser view.
      if ($view_mode !== 'teaser') {
        $quiz_form = drupal_get_form('quiz_start_quiz_button_form', $node);
        $node->content['take'] = array(
          '#markup' => drupal_render($quiz_form),
          '#weight' => 2,
        );
      }
      // Add a link to the take tab if this is a teaser view.
      else {
        $node->content['take'] = array(
          '#markup' => l(t('Start @quiz', array('@quiz' => QUIZ_NAME)), 'node/' . $node->nid . '/take'),
          '#weight' => 2,
        );
      }
    }
  }
  else {
    $node->content['take'] = array(
      '#markup' => '<div class="quiz-not-available">' . $available . '</div>',
      '#weight' => 2,
    );
  }

  return $node;
}

/**
 * Helper function for hook_view().
 *
 * Returns a button to use as a link to start taking the quiz.
 *
 * @param $form_state
 *   Form state array.
 * @param $node
 *   The quiz node.
 * @return
 *   Form with a button linking to the take tab.
 */
function quiz_start_quiz_button_form($form, &$form_state, $node) {
  $form = array();
  $form['#action'] = url("node/$node->nid/take");
  $form['button'] = array(
    '#type' => 'submit',
    '#value' => t('Start @quiz', array('@quiz' => QUIZ_NAME)),
  );
  return $form;
}

/**
 * Primary quiz-taking view on 'Take' tab.
 */
function quiz_take($node) {
  //drupal_alter('quiz_take', $node);
  if (isset($node->rendered_content)) {
    return $node->rendered_content;
  }
  $to_be_rendered = quiz_take_quiz($node);
  return drupal_render($to_be_rendered);
}

/**
 * Does the current user have access to take the quiz?
 *
 * @param $node
 *  The quiz node
 */
function quiz_take_access($node) {
  if ($node->type != 'quiz') {
    return FALSE;
  }
  return node_access('view', $node) && user_access('access quiz') && quiz_availability($node) === TRUE;
}

/**
 * Implements hook_form().
 *
 * This is an admin form used to build a new quiz. It is called as part of the
 * node edit form.
 */
function quiz_form(&$node, &$form_state) {

  $form = array();

  // We tell quiz_form_alter to check for the manual revisioning permission.
  $form['#quiz_check_revision_access'] = TRUE;

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#default_value' => isset($node->title) ? $node->title : '',
    '#description' => t('The name of this @quiz.', array('@quiz' => QUIZ_NAME)),
    '#required' => TRUE,
  );

  $form['taking'] = array(
    '#type' => 'fieldset',
    '#title' => t('Taking options'),
    '#collapsed' => isset($settings_loaded) ? $settings_loaded : FALSE,
    '#collapsible' => TRUE,
    '#attributes' => array('id' => 'taking-fieldset'),
    '#group' => 'additional_settings',
    '#weight' => -2,
  );
  $form['taking']['allow_resume'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow resume'),
    '#default_value' => $node->allow_resume,
    '#description' => t('Allow users to leave this @quiz incomplete and then resume it from where they left off.', array('@quiz' => QUIZ_NAME)),
  );
  $form['taking']['allow_skipping'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow skipping'),
    '#default_value' => $node->allow_skipping,
    '#description' => t('Allow users to skip questions in this @quiz.', array('@quiz' => QUIZ_NAME)),
  );
  $form['taking']['allow_jumping'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow jumping'),
    '#default_value' => $node->allow_jumping,
    '#description' => t('Allow users to jump to any question using a menu or pager in this @quiz.', array('@quiz' => QUIZ_NAME)),
  );
  $form['taking']['allow_change'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow changing answers'),
    '#default_value' => $node->allow_change,
    '#description' => t('If the user is able to visit a previous question, allow them to change the answer.'),
  );
  $form['taking']['backwards_navigation'] = array(
    '#type' => 'checkbox',
    '#title' => t('Backwards navigation'),
    '#default_value' => $node->backwards_navigation,
    '#description' => t('Allow users to go back and revisit questions already answered.'),
  );
  $form['taking']['repeat_until_correct'] = array(
    '#type' => 'checkbox',
    '#title' => t('Repeat until correct'),
    '#default_value' => $node->repeat_until_correct,
    '#description' => t('Require the user to retry the question until answered correctly.'),
  );
  $form['taking']['mark_doubtful'] = array(
    '#type' => 'checkbox',
    '#title' => t('Mark doubtful'),
    '#default_value' => $node->mark_doubtful,
    '#description' => t('Allow users to mark their answers as doubtful.'),
  );
  $form['taking']['show_passed'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show passed status'),
    '#default_value' => $node->show_passed,
    '#description' => t('Show a message if the user has previously passed the @quiz.', array('@quiz' => QUIZ_NAME)),
  );

  $form['taking']['randomization'] = array(
    '#type' => 'radios',
    '#title' => t('Randomize questions'),
    '#options' => array(
      t('No randomization'),
      t('Random order'),
      t('Random questions'),
      t('Categorized random questions'),
    ),
    '#description' => t('<strong>Random order</strong> - all questions display in random order')
    . '<br/>' . t("<strong>Random questions</strong> - specific number of questions are drawn randomly from this @quiz's pool of questions", array('@quiz' => QUIZ_NAME))
    . '<br/>' . t('<strong>Categorized random questions</strong> - specific number of questions are drawn from each specified taxonomy term'),
    '#default_value' => $node->randomization,
  );
  $form['taking']['review_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Review options'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
    '#description' => t('Control what feedback appears and when.'),
  );

  $review_options = quiz_get_feedback_options();

  foreach (array('question' => 'After the question', 'end' => t('After the @quiz', array('@quiz' => QUIZ_NAME))) as $key => $when) {
    $form['taking']['review_options'][$key] = array(
      '#title' => $when,
      '#type' => 'checkboxes',
      '#options' => $review_options,
      '#default_value' => isset($node->review_options[$key]) ? $node->review_options[$key] : array(),
    );
  }
  $options = array(t('Unlimited'));
  for ($i = 1; $i < 10; $i++) {
    $options[$i] = $i;
  }
  $form['taking']['multiple_takes'] = array(
    '#type' => 'fieldset',
    '#title' => t('Multiple takes'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#attributes' => array('id' => 'multiple-takes-fieldset'),
    '#description' => t('Allow users to take this @quiz multiple times.', array('@quiz' => QUIZ_NAME)),
  );
  $form['taking']['multiple_takes']['takes'] = array(
    '#type' => 'select',
    '#title' => t('Allowed number of attempts'),
    '#default_value' => $node->takes,
    '#options' => $options,
    '#description' => t('The number of times a user is allowed to take this @quiz. <strong>Anonymous users are only allowed to take @quiz that allow an unlimited number of attempts.</strong>', array('@quiz' => QUIZ_NAME)),
  );
  $form['taking']['multiple_takes']['show_attempt_stats'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display allowed number of attempts'),
    '#default_value' => $node->show_attempt_stats,
    '#description' => t('Display the allowed number of attempts on the starting page for this @quiz.', array('@quiz' => QUIZ_NAME)),
  );

  if (user_access('delete any quiz results') || user_access('delete results for own quiz')) {
    $form['taking']['multiple_takes']['keep_results'] = array(
      '#type' => 'radios',
      '#title' => t('Store results'),
      '#description' => t('These results should be stored for each user.'),
      '#options' => array(
        t('The best'),
        t('The newest'),
        t('All'),
      ),
      '#default_value' => $node->keep_results,
    );
  }
  else {
    $form['taking']['multiple_takes']['keep_results'] = array(
      '#type' => 'value',
      '#value' => $node->keep_results,
    );
  }

  $form['taking']['time_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Time limit'),
    '#default_value' => isset($node->time_limit) ? $node->time_limit : 0,
    '#description' => t('Set the maximum allowed time in seconds for this @quiz. Use 0 for no limit.', array('@quiz' => QUIZ_NAME))
    . '<br/>' . t('It is recommended to install the !countdown module, and enable the option in !link to show the time left to the user.', array(
      '!link' => l('Quiz configuration', 'admin/quiz/settings/config'),
      '!countdown' => l('jquery_countdown', 'http://drupal.org/project/jquery_countdown'),
  )));

  if (function_exists('userpoints_userpointsapi') && variable_get('quiz_has_userpoints', 1)) {
    $form['userpoints'] = array(
      '#type' => 'fieldset',
      '#title' => t('Userpoints'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#group' => 'additional_settings',
    );
    $form['userpoints']['has_userpoints'] = array(
      '#type' => 'checkbox',
      '#default_value' => (isset($node->has_userpoints) ? $node->has_userpoints : 1),
      '#title' => t('Enable UserPoints Module Integration'),
      '#description' => t('If checked, marks scored in this @quiz will be credited to userpoints. For each correct answer 1 point will be added to user\'s point.', array('@quiz' => QUIZ_NAME)),
    );
    $form['userpoints']['userpoints_tid'] = array(
      '#type' => 'select',
      '#options' => _quiz_userpoints_type(),
      '#title' => t('Userpoints Category'),
      '#states' => array(
        'visible' => array(
          ':input[name=has_userpoints]' => array('checked' => TRUE),
        ),
      ),
      '#default_value' => isset($node->userpoints_tid) ? $node->userpoints_tid : 0,
      '#description' => t('Select the category to which user points to be added. To add new category see <a href="!url">admin/structure/taxonomy/userpoints</a>', array('!url' => url('admin/structure/taxonomy/userpoints'))),
    );
  }

  // Set up the availability options.
  $form['quiz_availability'] = array(
    '#type' => 'fieldset',
    '#title' => t('Availability options'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
    '#attributes' => array('id' => 'availability-fieldset'),
    '#group' => 'additional_settings',
  );

  $form['quiz_availability']['quiz_always'] = array(
    '#type' => 'checkbox',
    '#title' => t('Always available'),
    '#default_value' => $node->quiz_always,
    '#description' => t('Ignore the open and close dates.'),
    '#disabled' => !module_exists('date_popup'),
  );

  if (module_exists('date_popup')) {
    $format = 'Y-m-d H:i';
    $form['quiz_availability']['quiz_open'] = array(
      '#type' => 'date_popup',
      '#title' => t('Open date'),
      '#default_value' => date($format, $node->quiz_open ? $node->quiz_open : REQUEST_TIME),
      '#description' => t('The date this @quiz will become available.', array('@quiz' => QUIZ_NAME)),
    );
    $form['quiz_availability']['quiz_close'] = array(
      '#type' => 'date_popup',
      '#title' => t('Close date'),
      '#default_value' => date($format, $node->quiz_close ? $node->quiz_close : REQUEST_TIME + variable_get('quiz_default_close', 30) * 86400),
      '#description' => t('The date this @quiz will become unavailable.', array('@quiz' => QUIZ_NAME)),
    );
  }
  else {
    $form['quiz_availability']['help']['#markup'] = t('Enable the Date Popup (date_popup) module from the !date project to enable support for open and close dates.', array('!date' => l('Date', 'http://drupal.org/project/date')));
  }

  // Quiz summary options.
  $form['summaryoptions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Pass/fail options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#attributes' => array('id' => 'summaryoptions-fieldset'),
    '#group' => 'additional_settings',
  );
  // If pass/fail option is checked, present the form elements.
  if (variable_get('quiz_use_passfail', 1)) {
    $form['summaryoptions']['pass_rate'] = array(
      '#type' => 'textfield',
      '#title' => t('Passing rate for @quiz (%)', array('@quiz' => QUIZ_NAME)),
      '#default_value' => $node->pass_rate,
      '#description' => t('Passing rate for this @quiz as a percentage score.', array('@quiz' => QUIZ_NAME)),
      '#required' => FALSE,
    );
    $form['summaryoptions']['summary_pass'] = array(
      '#type' => 'text_format',
      '#base_type' => 'textarea',
      '#title' => t('Summary text if passed'),
      '#default_value' => $node->summary_pass,
      '#cols' => 60,
      '#description' => t("Summary text for when the user passes the @quiz. Leave blank to not give different summary text if passed, or if not using the \"percent to pass\" option above. If not using the \"percentage needed to pass\" field above, this text will not be used.", array('@quiz' => QUIZ_NAME)),
      '#format' => isset($node->summary_pass_format) && !empty($node->summary_pass_format) ? $node->summary_pass_format : NULL,
    );
  }
  // If the pass/fail option is unchecked, use the default and hide it.
  else {
    $form['summaryoptions']['pass_rate'] = array(
      '#type' => 'hidden',
      '#value' => $node->pass_rate,
      '#required' => FALSE,
    );
  }
  // We use a helper to enable the wysiwyg module to add an editor to the
  // textarea.
  $form['summaryoptions']['helper']['summary_default'] = array(
    '#type' => 'text_format',
    '#base_type' => 'textarea',
    '#title' => t('Default summary text'),
    '#default_value' => $node->summary_default,
    '#cols' => 60,
    '#description' => t("Default summary. Leave blank if you don't want to give a summary."),
    '#format' => isset($node->summary_default_format) && !empty($node->summary_default_format) ? $node->summary_default_format : NULL,
  );

  // Number of random questions, max score and tid for random questions are set on
  // the manage questions tab. We repeat them here so that they're not removed
  // if the quiz is being updated.
  $num_rand = (isset($node->number_of_random_questions)) ? $node->number_of_random_questions : 0;
  $form['number_of_random_questions'] = array(
    '#type' => 'value',
    '#value' => $num_rand,
  );
  $max_score_for_random = (isset($node->max_score_for_random)) ? $node->max_score_for_random : 0;
  $form['max_score_for_random'] = array(
    '#type' => 'value',
    '#value' => $max_score_for_random,
  );
  $tid = (isset($node->tid)) ? $node->tid : 0;
  $form['tid'] = array(
    '#type' => 'value',
    '#value' => $tid,
  );

  $options = !empty($node->resultoptions) ? $node->resultoptions : array();
  $num_options = max(count($options), variable_get('quiz_max_result_options', 5));

  if ($num_options > 0) {
    $form['resultoptions'] = array(
      '#type' => 'fieldset',
      '#title' => t('Result feedback'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#tree' => TRUE,
      '#attributes' => array('id' => 'resultoptions-fieldset'),
      '#group' => 'additional_settings',
    );

    for ($i = 0; $i < $num_options; $i++) {
      $option = (count($options) > 0) ? array_shift($options) : NULL; // grab each option in the array
      $form['resultoptions'][$i] = array(
        '#type' => 'fieldset',
        '#title' => t('Result Option ') . ($i + 1),
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
      );
      $form['resultoptions'][$i]['option_name'] = array(
        '#type' => 'textfield',
        '#title' => t('Range title'),
        '#default_value' => isset($option['option_name']) ? $option['option_name'] : '',
        '#maxlength' => 40,
        '#size' => 40,
        '#description' => 'e.g., "A" or "Passed"',
      );
      $form['resultoptions'][$i]['option_start'] = array(
        '#type' => 'textfield',
        '#title' => t('Percentage low'),
        '#description' => t('Show this result for scored @quiz in this range (0-100).', array('@quiz' => QUIZ_NAME)),
        '#default_value' => isset($option['option_start']) ? $option['option_start'] : '',
        '#size' => 5,
      );
      $form['resultoptions'][$i]['option_end'] = array(
        '#type' => 'textfield',
        '#title' => t('Percentage high'),
        '#description' => t('Show this result for scored @quiz in this range (0-100).', array('@quiz' => QUIZ_NAME)),
        '#default_value' => isset($option['option_end']) ? $option['option_end'] : '',
        '#size' => 5,
      );
      $form['resultoptions'][$i]['option_summary'] = array(
        '#type' => 'text_format',
        '#base_type' => 'textarea',
        '#title' => t('Feedback'),
        '#default_value' => isset($option['option_summary']) ? $option['option_summary'] : '',
        '#description' => t("This is the text that will be displayed when the user's score falls in this range."),
        '#format' => isset($option['option_summary_format']) ? $option['option_summary_format'] : NULL,
      );
      if (isset($option['option_id'])) {
        $form['resultoptions'][$i]['option_id'] = array(
          '#type' => 'hidden',
          '#value' => isset($option['option_id']) ? $option['option_id'] : '',
        );
      }
    }
  }

  $form['remember_settings'] = array(
    '#type' => 'checkbox',
    '#title' => t('Remember my settings'),
    '#description' => t('If this box is checked most of the @quiz specific settings you have made will be remembered and will be your default settings next time you create a @quiz.', array('@quiz' => QUIZ_NAME)),
    '#weight' => 49,
  );

  $form['remember_global'] = array(
    '#type' => 'checkbox',
    '#title' => t('Remember as global'),
    '#description' => t('If this box is checked most of the @quiz specific settings you have made will be remembered and will be everyone\'s default settings next time they create a @quiz.', array('@quiz' => QUIZ_NAME)),
    '#weight' => 49,
    '#access' => user_access('administer quiz configuration'),
  );

  if (quiz_has_been_answered($node) && (!user_access('manual quiz revisioning') || variable_get('quiz_auto_revisioning', 1))) {
    $node->revision = 1;
    $node->log = t('The current revision has been answered. We create a new revision so that the reports from the existing answers stays correct.');
  }
  return $form;
}

function _quiz_userpoints_type() {
  $userpoints_terms = taxonomy_get_tree(userpoints_get_vid());
  $userpoints_tids = array(0 => t('Select'));
  foreach ($userpoints_terms as $userpoints_term) {
    $userpoints_tids[$userpoints_term->tid] = str_repeat('-', $userpoints_term->depth) . $userpoints_term->name;
  }
  return $userpoints_tids;
}

/**
 * Implements hook_validate().
 */
function quiz_validate($node) {
  // Don't check dates if the quiz is always available.
  if (!$node->quiz_always) {
    if (mktime(0, 0, 0, $node->quiz_open['month'], $node->quiz_open['day'], $node->quiz_open['year']) > mktime(0, 0, 0, $node->quiz_close['month'], $node->quiz_close['day'], $node->quiz_close['year'])) {
      form_set_error('quiz_close', t('"Close date" must be later than the "open date".'));
    }
  }

  if (!empty($node->pass_rate)) {
    if (!_quiz_is_int($node->pass_rate, 0, 100)) {
      form_set_error('pass_rate', t('"Passing rate" must be a number between 0 and 100.'));
    }
  }

  if (isset($node->time_limit)) {
    if (!_quiz_is_int($node->time_limit, 0)) {
      form_set_error('time_limit', t('"Time limit" must be a positive number.'));
    }
  }

  if (isset($node->resultoptions) && count($node->resultoptions) > 0) {
    $taken_values = array();
    $num_options = 0;
    foreach ($node->resultoptions as $option) {
      if (!empty($option['option_name'])) {
        $num_options++;
        if (empty($option['option_summary'])) {
          form_set_error('option_summary', t('Range has no summary text.'));
        }
        if ($node->pass_rate && (isset($option['option_start']) || isset($option['option_end']))) {

          // Check for a number between 0-100.
          foreach (array('option_start' => 'start', 'option_end' => 'end') as $bound => $bound_text) {
            if (!_quiz_is_int($option[$bound], 0, 100)) {
              form_set_error($bound, t('The range %start value must be a number between 0 and 100.', array('%start' => $bound_text)));
            }
          }

          // Check that range end >= start.
          if ($option['option_start'] > $option['option_end']) {
            form_set_error('option_start', t('The start must be less than the end of the range.'));
          }

          // Check that range doesn't collide with any other range.
          $option_range = range($option['option_start'], $option['option_end']);
          if ($intersect = array_intersect($taken_values, $option_range)) {
            form_set_error('option_start', t('The ranges must not overlap each other. (%intersect)', array('%intersect' => implode(',', $intersect))));
          }
          else {
            $taken_values = array_merge($taken_values, $option_range);
          }
        }
      }
      elseif (!_quiz_is_empty_html($option['option_summary']['value'])) {
        form_set_error('option_summary', t('Range has a summary, but no name.'));
      }
    }
  }
  if ($node->allow_jumping && !$node->allow_skipping) {
    // @todo when we have pages of questions, we have to check that jumping is
    // not enabled, and randomization is not enabled unless there is only 1 page
    form_set_error('allow_skipping', t('If jumping is allowed, skipping must also be allowed.'));
  }
}

/**
 * Implements hook_node_presave().
 */
function quiz_node_presave($node) {
  if ($node->type == 'quiz') {
    // Convert the action id to the actual id from the MD5 hash.
    // Why the actions module does this I do not know? Maybe to prevent
    // invalid values put into the options value="" field.
    if (!empty($node->aid) && $aid = actions_function_lookup($node->aid)) {
      $node->aid = $aid;
    }

    if (variable_get('quiz_auto_revisioning', 1)) {
      $node->revision = (quiz_has_been_answered($node)) ? 1 : 0;
    }

    // If this is a programmatic save, ensure we use the defaults.
    $defaults = quiz_get_defaults();
    foreach ($defaults as $property => $value) {
      if (!isset($node->$property)) {
        $node->$property = $defaults->$property;
      }
    }
  }
  if (isset($node->is_quiz_question) && variable_get('quiz_auto_revisioning', 1)) {
    $node->revision = (quiz_question_has_been_answered($node)) ? 1 : 0;
  }
}

/**
 * Implements hook_node_prepare().
 */
function quiz_node_prepare($node) {
  if ($node->type == 'quiz' && !isset($node->nid)) {
    // If this is a new node we apply the user defaults for the quiz settings.
    if (arg(0) == 'node') {
      drupal_set_message(t('You are making your first @quiz. On this page you set the attributes, most of which you may tell the system to remember as defaults for the future. On the next screen you can add questions.', array('@quiz' => QUIZ_NAME)));
    }
    $settings = quiz_get_defaults();
    foreach ($settings as $key => $value) {
      if (!isset($node->$key)) {
        $node->$key = $value;
      }
    }
  }

  if (isset($node->is_quiz_question)) {
    if (variable_get('quiz_auto_revisioning', 1)) {
      $node->revision = (quiz_question_has_been_answered($node)) ? 1 : 0;
    }
  }
}

/**
 * Implements hook_user_cancel().
 */
function quiz_user_cancel($edit, $account, $method) {
  if (variable_get('quiz_durod', 0)) {
    _quiz_delete_users_results($account->uid);
  }
}

/**
 * Deletes all results associated with a given user.
 *
 * @param int $uid
 *  The users id
 */
function _quiz_delete_users_results($uid) {
  $res = db_query("SELECT result_id FROM {quiz_node_results} WHERE uid = :uid", array(':uid' => $uid));
  $result_ids = array();
  while ($result_id = $res->fetchField()) {
    $result_ids[] = $result_id;
  }
  entity_delete_multiple('quiz_result', $result_ids);
}

/**
 * @defgroup quiz_public Public API functions.
 * @{
 */

/**
 * Validate that a node is of type quiz, and that the user has access to it.
 *
 * @param $node
 * @param $op
 * @return unknown_type
 */
function quiz_type_confirm($node, $op = NULL) {
  if ($node->type != 'quiz') {
    return FALSE;
  }
  if (isset($op)) {
    $node_ops = array('view', 'update', 'delete', 'create');
    if (in_array($op, $node_ops)) {
      return node_access($op, $node);
    }
    return user_access($op);
  }

  return user_access('access quiz');
}

/**
 * Returns the titles for all quizzes the user has access to.
 *
 * @return quizzes
 *   Array with nids as keys and titles as values.
 */
function quiz_get_all_titles() {
  return db_select('node', 'n')
      ->fields('n', array('nid', 'title'))
      ->condition('n.type', 'quiz')
      ->addTag('node_access')
      ->execute()
      ->fetchAllKeyed();
}

/**
 * Returns the titles for all quizzes the user has access to.
 *
 * @return quizzes
 *   Array with nids as keys and (array with vid as key and title as value) as values.
 *   Like this: array($nid => array($vid => $title))
 */
function quiz_get_all_version_titles() {
  $query = db_select('node', 'n');
  $query->join('node_revision', 'nr', 'nr.nid = n.nid');
  $query->fields('nr', array('nid', 'vid', 'title'))
    ->condition('n.type', 'quiz')
    ->execute();

  $to_return = array();
  while ($res_o = $query->fetch()) {
    $to_return[$res_o->nid][$res_o->vid] = $res_o->title;
  }
  return $to_return;
}

/**
 * Return highest score data for given quizzes.
 *
 * @param $nids
 *   nids for the quizzes we want to collect scores from.
 * @param $uid
 *   uid for the user we want to collect score for.
 * @param $include_num_questions
 *   Do we want to collect information about the number of questions in a quiz?
 *   This adds a performance hit.
 * @return
 *   Array of score data.
 *   For several takes on the same quiz, only returns highest score.
 */
function quiz_get_score_data($nids, $uid, $include_num_questions = FALSE) {
  // Validate that the nids are integers.
  foreach ($nids as $key => $nid) {
    if (!_quiz_is_int($nid)) {
      unset($nids[$key]);
    }
  }
  if (empty($nids)) {
    return array();
  }

  // Fetch score data for the validated nids.
  $to_return = array();
  $vids = array();
  $sql = 'SELECT n.title, n.nid, n.vid, p.number_of_random_questions as num_random_questions, r.score AS percent_score, p.max_score, p.pass_rate AS percent_pass
          FROM {node} n
          JOIN {quiz_node_properties} p
          ON n.vid = p.vid
          LEFT OUTER JOIN {quiz_node_results} r
          ON r.nid = n.nid AND r.uid = :uid
          LEFT OUTER JOIN (
            SELECT nid, max(score) as highest_score
            FROM {quiz_node_results}
            GROUP BY nid
          ) rm
          ON n.nid = rm.nid AND r.score = rm.highest_score
          WHERE n.nid in (' . implode(', ', $nids) . ')
          ';
  $res = db_query($sql, array(':uid' => $uid));
  foreach ($res as $res_o) {
    if (!$include_num_questions) {
      unset($res_o->num_random_questions);
    }
    if (!isset($to_return[$res_o->vid]) || $res_o->percent_score > $to_return[$res_o->vid]->percent_score) {
      $to_return[$res_o->vid] = $res_o; // Fetch highest score
    }
    // $vids will be used to fetch number of questions.
    $vids[] = $res_o->vid;
  }
  if (empty($vids)) {
    return array();
  }

  // Fetch total number of questions.
  if ($include_num_questions) {
    $res = db_query('SELECT COUNT(*) AS num_always_questions, parent_vid
            FROM {quiz_node_relationship}
            WHERE parent_vid IN (' . implode(', ', $vids) . ')
            AND question_status = ' . QUESTION_ALWAYS . '
            GROUP BY parent_vid');
    foreach ($res as $res_o) {
      $to_return[$res_o->parent_vid]->num_questions = $to_return[$res_o->parent_vid]->num_random_questions + $res_o->num_always_questions;
    }
  }

  return $to_return;
}

/**
 * Finds out the number of questions for the quiz.
 *
 * Good example of usage could be to calculate the % of score.
 *
 * @param $nid
 *   Quiz ID.
 * @return
 *   Returns the number of quiz questions.
 */
function quiz_get_number_of_questions($vid) {
  $always_count = _quiz_get_num_always_questions($vid);
  $rand_count = db_query('SELECT number_of_random_questions FROM {quiz_node_properties} WHERE vid = :vid', array(':vid' => $vid))->fetchField();
  return $always_count + (int) $rand_count;
}

/**
 * Copies quiz-question relation entries in the quiz_node_relationship table
 * from an old version of a quiz to a new.
 *
 * @param $old_quiz_vid
 *   The quiz vid prior to a new revision.
 * @param $new_quiz_vid
 *   The quiz vid of the latest revision.
 * @param $quiz_nid
 *   The quiz node id.
 */
function quiz_update_quiz_question_relationship($old_quiz_vid, $new_quiz_vid, $quiz_nid) {
  // query for questions in previous version
  $result = db_select('quiz_node_relationship', 'qnr')
    ->fields('qnr', array('parent_nid', 'child_nid', 'child_vid', 'question_status', 'weight', 'max_score', 'auto_update_max_score', 'qnr_id', 'qnr_pid'))
    ->condition('parent_nid', $quiz_nid)
    ->condition('parent_vid', $old_quiz_vid)
    ->condition('question_status', QUESTION_NEVER, '!=')
    ->execute();

  // only proceed if query returned data
  if ($result->rowCount()) {
    $questions = $result->fetchAll(PDO::FETCH_ASSOC);
    foreach ($questions as &$quiz_question) {
      $quiz_question['old_qnr_id'] = $quiz_question['qnr_id'];
      $quiz_question['parent_nid'] = $quiz_nid;
      $quiz_question['parent_vid'] = $new_quiz_vid;
      unset($quiz_question['qnr_id']);
      drupal_write_record('quiz_node_relationship', $quiz_question);
    }

    // Update the parentage when a new revision is created.
    // @todo this is copy pasta from quiz_set_questions
    foreach ($questions as $question) {
      db_update('quiz_node_relationship')
        ->condition('qnr_pid', $question['old_qnr_id'])
        ->condition('parent_nid', $quiz_nid)
        ->condition('parent_vid', $new_quiz_vid)
        ->fields(array('qnr_pid' => $question['qnr_id']))
        ->execute();
    }
  }

  /* Update terms if any */
  $result = db_select('quiz_terms', 'qt')
    ->fields('qt', array('nid', 'tid', 'weight', 'max_score', 'number'))
    ->condition('vid', $old_quiz_vid)
    ->execute();
  // only proceed if query returned data
  if ($result->rowCount()) {
    $insert_query = db_insert('quiz_terms')
      ->fields(array('nid', 'vid', 'tid', 'weight', 'max_score', 'number'));
    while ($quiz_term = $result->fetchAssoc()) {
      $insert_query->values(array(
        'nid' => $quiz_nid,
        'vid' => $new_quiz_vid,
        'tid' => $quiz_term['tid'],
        'weight' => $quiz_term['weight'],
        'max_score' => $quiz_term['max_score'],
        'number' => $quiz_term['number'],
      ));
    }
    $insert_query->execute();
  }

  /* $sql = "INSERT INTO {quiz_terms} (nid, vid, tid, weight, max_score, number)
    SELECT qt.nid, %d, qt.tid, qt.weight, qt.max_score, qt.number
    FROM {quiz_terms} qt
    WHERE qt.vid = %d"; */
}

/**
 * Handles quiz taking.
 *
 * This gets executed when the main quiz node is first loaded.
 *
 * @param $quiz
 *   The quiz node.
 *
 * @return
 *   Content array.
 */
function quiz_take_quiz($quiz) {
  global $user;

  // Make sure we use the same revision of the quiz throughout the quiz taking
  // session.
  $result_id = !empty($_SESSION['quiz'][$quiz->nid]['result_id']) ? $_SESSION['quiz'][$quiz->nid]['result_id'] : NULL;
  if ($result_id && $quiz_result = quiz_result_load($result_id)) {
    // Enforce that we have the same quiz version.
    $quiz = node_load($quiz_result->nid, $quiz_result->vid);
  }
  else {
    // User doesn't have attempt in session. If we allow resuming we can load it
    // from the database.
    if ($quiz->allow_resume && !user_is_anonymous()) {
      if ($result_id = _quiz_active_result_id($user->uid, $quiz->nid, $quiz->vid)) {
        $_SESSION['quiz'][$quiz->nid]['result_id'] = $result_id;
        $_SESSION['quiz'][$quiz->nid]['current'] = 1;
        $quiz_result = quiz_result_load($result_id);
        $quiz = node_load($quiz_result->nid, $quiz_result->vid);
        // Resume a quiz from the database.
        drupal_set_message(t('Resuming a previous @quiz in-progress.', array('@quiz' => QUIZ_NAME)), 'status');
      }
    }
  }

  if (!$result_id) {
    // Can user start quiz?
    if (quiz_start_check($quiz)) {
      // Set up a new attempt.
      $quiz_result = quiz_create_attempt($quiz);
      $_SESSION['quiz'][$quiz->nid]['result_id'] = $quiz_result->result_id;
      $_SESSION['quiz'][$quiz->nid]['current'] = 1;

      // Call hook_quiz_begin().
      module_invoke_all('quiz_begin', $quiz, $quiz_result->result_id);
    }
    else {
      return array('body' => array('#markup' => t('This @quiz is closed.', array('@quiz' => QUIZ_NAME))));
    }
  }

  if (!quiz_availability($quiz)) {
    return array('body' => array('#markup' => t('This @quiz is not available.', array('@quiz' => QUIZ_NAME))));
  }

  drupal_goto("node/{$quiz->nid}/take/" . ($_SESSION['quiz'][$quiz->nid]['current']));
}

/**
 * Take a quiz questions.
 *
 * @param type $quiz
 *   A quiz node.
 * @param type $question_number
 *   A question number, starting at 1. Pages do not have question numbers. Quiz
 *   directions are considered part of the numbering.
 */
function quiz_take_question($quiz, $question_number) {
  if (!empty($_SESSION['quiz'][$quiz->nid]['result_id'])) {
    $quiz_result = quiz_result_load($_SESSION['quiz'][$quiz->nid]['result_id']);
    $question = $quiz_result->layout[$question_number];

    if (!empty($question['qnr_pid'])) {
      // Find the parent.
      foreach ($quiz_result->layout as $pquestion) {
        if ($pquestion['qnr_id'] == $question['qnr_pid']) {
          // Load the page that the requested question belongs to.
          $question_node = node_load($pquestion['nid'], $pquestion['vid']);
        }
      }
    }
    else {
      // Load the question.
      $question_node = node_load($question['nid'], $question['vid']);
    }
  }

  if (!$question_node) {
    // Question disappeared or invalid session. Start over.
    unset($_SESSION['quiz'][$quiz->nid]);
    drupal_goto("node/{$quiz->nid}");
  }

  // Mark this as the current question.
  quiz_question_goto($quiz, $question_number);

  // Added the progress info to the view.
  $quiz_result = quiz_result_load($_SESSION['quiz'][$quiz->nid]['result_id']);
  $questions = array();
  $i = 0;
  foreach ($quiz_result->layout as $idx => $question) {
    if (empty($question['qnr_pid'])) {
      // Question has no parent. Show it in the jumper.
      $questions[$idx] = ++$i;
    }
  }

  $content['progress']['#markup'] = theme('quiz_progress', array(
    'questions' => $questions,
    'current' => arg(3),
    'allow_jumping' => $quiz->allow_jumping,
    'pager' => count($questions) >= variable_get('quiz_pager_start', 100),
    'time_limit' => $quiz->time_limit,
  ));
  $content['progress']['#weight'] = -50;

  /**
   * @todo: wat do?
    if (count($_SESSION['quiz'][$quiz->nid]['quiz_questions']) + count($_SESSION['quiz'][$quiz->nid]['previous_quiz_questions']) > $number_of_questions) {
    drupal_set_message(t('At least one question have been deleted from the quiz after you started taking it. You will have to start over.'), 'warning', FALSE);
    unset($_SESSION['quiz'][$quiz->nid]);
    drupal_goto('node/' . $quiz->nid . '/take');
    }
   */
  if (function_exists('jquery_countdown_add') && variable_get('quiz_has_timer', 0) && $quiz->time_limit) {
    jquery_countdown_add('.countdown', array('until' => ($quiz_result->time_start + $quiz->time_limit - REQUEST_TIME), 'onExpiry' => 'finished', 'compact' => TRUE, 'layout' => t('Time left') . ': {hnn}{sep}{mnn}{sep}{snn}'));
    // These are the two button op values that are accepted for answering
    // questions.
    $button_op1 = drupal_json_encode(t('Finish'));
    $button_op2 = drupal_json_encode(t('Next'));
    $js = "
            function finished() {
              // Find all buttons with a name of 'op'.
              var buttons = jQuery('input[type=submit][name=op], button[type=submit][name=op]');
              // Filter out the ones that don't have the right op value.
              buttons = buttons.filter(function() {
                return this.value == $button_op1 || this.value == $button_op2;
              });
              if (buttons.length == 1) {
                // Since only one button was found, this must be it.
                buttons.click();
              }
              else {
                // Zero, or more than one buttons were found; fall back on a page refresh.
                window.location = window.location.href;
              }
            }
          ";
    drupal_add_js($js, array('type' => 'inline', 'scope' => JS_DEFAULT));
  }

  $question_form = drupal_get_form('quiz_question_answering_form', $question_node, $_SESSION['quiz'][arg(1)]['result_id']);
  $content['body']['question']['#markup'] = drupal_render($question_form);
  drupal_set_title($quiz->title);


  return $content;
}

/**
 * Initialize a new attempt for a Quiz for the current user.
 *
 * This builds a question list from the list of questions or random options,
 * then instantiates the attempt layout in the database.
 *
 * This function does not set the quiz attempt as current, the calling function
 * should then set the current quiz attempt in the session for the user to be
 * able to take it.
 *
 * @todo wrap around entity_create()? We are creating an entity here anyway.
 *
 * @return stdClass
 *   The quiz attempt/result.
 */
function quiz_create_attempt($quiz) {
  // Create question list.
  $questions = quiz_build_question_list($quiz);
  if ($questions === FALSE) {
    drupal_set_message(t('Not enough random questions were found. Please add more questions before trying to take this @quiz.', array('@quiz' => QUIZ_NAME)), 'error');
    return FALSE;
  }

  if (count($questions) == 0) {
    drupal_set_message(t('No questions were found. Please !assign_questions before trying to take this @quiz.', array('@quiz' => QUIZ_NAME, '!assign_questions' => l(t('assign questions'), 'node/' . $quiz->nid . '/quiz/questions'))), 'error');
    return FALSE;
  }

  $quiz_result = quiz_result_load(quiz_create_rid($quiz));

  // Write the layout for this result.
  entity_save('quiz_result', $quiz_result);
  $i = 0;
  foreach ($questions as $question) {
    $quiz_result_answer = entity_create('quiz_result_answer', array(
      'result_id' => $quiz_result->result_id,
      'question_nid' => $question['nid'],
      'question_vid' => $question['vid'],
      'number' => ++$i,
    ));
    entity_save('quiz_result_answer', $quiz_result_answer);
  }

  return quiz_result_load($quiz_result->result_id);
}

/**
 * Store a quiz question result.
 *
 * @param $quiz
 *  The quiz node
 * @param $result
 *  Object with data about the result for a question.
 * @param $options
 *  Array with options that affect the behavior of this function.
 *  ['set_msg'] - Sets a message if the last question was skipped.
 */
function quiz_store_question_result($quiz, $result, $options) {
  if (!isset($result->score)) {
    $result->score = $result->is_correct ? 1 : 0;
  }

  // Points are stored pre-scaled in the quiz_node_results_answers table. We get the scale.
  if ($quiz->randomization < 2) {
    $scale = db_query("SELECT (max_score / (
                  SELECT max_score
                  FROM {quiz_question_properties}
                  WHERE nid = :nid AND vid = :vid
                )) as scale
                FROM {quiz_node_relationship}
                WHERE parent_nid = :parent_nid
                AND parent_vid = :parent_vid
                AND child_nid = :child_nid
                AND child_vid = :child_vid
               ", array(':nid' => $result->nid, ':vid' => $result->vid, ':parent_nid' => $quiz->nid, ':parent_vid' => $quiz->vid, ':child_nid' => $result->nid, ':child_vid' => $result->vid))->fetchField();
  }
  elseif ($quiz->randomization == 2) {
    $scale = db_query("SELECT (max_score_for_random / (
                  SELECT max_score
                  FROM {quiz_question_properties}
                  WHERE nid = :question_nid AND vid = :question_vid
                )) as scale
                FROM {quiz_node_properties}
                WHERE vid = :quiz_vid
               ", array(':question_nid' => $result->nid, ':question_vid' => $result->vid, ':quiz_vid' => $quiz->vid))->fetchField();
  }
  elseif ($quiz->randomization == 3) {
    if (isset($options['question_data']['tid'])) {
      $result->tid = $options['question_data']['tid'];
    }
    $scale = db_query("SELECT (max_score / (
                  SELECT max_score
                  FROM {quiz_question_properties}
                  WHERE nid = :nid AND vid = :vid
                )) as scale
                FROM {quiz_terms}
                WHERE vid = :vid
                AND tid = :tid
               ", array(':nid' => $result->nid, ':vid' => $result->vid, ':vid' => $quiz->vid, ':tid' => $result->tid))->fetchField();
  }
  $points = round($result->score * $scale);
  // Insert result data, or update existing data.
  $result_answer_id = db_query("SELECT result_answer_id
              FROM {quiz_node_results_answers}
              WHERE question_nid = :question_nid
              AND question_vid = :question_vid
              AND result_id = :result_id", array(':question_nid' => $result->nid, ':question_vid' => $result->vid, ':result_id' => $result->result_id))->fetchField();

  $entity = (object) array(
      'result_answer_id' => $result_answer_id,
      'question_nid' => $result->nid,
      'question_vid' => $result->vid,
      'result_id' => $result->result_id,
      'is_correct' => (int) $result->is_correct,
      'points_awarded' => $points,
      'answer_timestamp' => REQUEST_TIME,
      'is_skipped' => (int) $result->is_skipped,
      'is_doubtful' => (int) $result->is_doubtful,
      'number' => $options['question_data']['number'],
      'tid' => ($quiz->randomization == 3 && $result->tid) ? $result->tid : NULL,
  );
  entity_save('quiz_result_answer', $entity);
}

/**
 * Score a completed quiz.
 */
function quiz_end_scoring($result_id) {
  global $user;
  $quiz_result = quiz_result_load($result_id);
  $quiz = node_load($quiz_result->nid, $quiz_result->vid);
  $questions = $quiz_result->layout;

  // Mark all missing answers as blank. This is essential here for when we may
  // have pages of unanswered questions. Also kills a lot of the skip code that
  // was necessary before.
  foreach ($quiz_result->layout as $qinfo) {
    // Load the Quiz answer submission from the database.
    $qra = quiz_result_answer_load($result_id, $qinfo['nid'], $qinfo['vid']);
    $current_question = node_load($qinfo['nid'], $qinfo['vid']);

    foreach ($questions as $question) {
      if ($question['nid'] == $current_question->nid) {
        $question_array = $question;
      }
    }

    if (!$qra) {
      // This is the same skip code as in quiz_question_answering_form_submit() @todo find a way to save code.
      $qi_instance = _quiz_question_response_get_instance($result_id, $current_question, NULL);
      $qi_instance->delete();
      $bare_object = $qi_instance->toBareObject();
      quiz_store_question_result($quiz, $bare_object, array('set_msg' => TRUE, 'question_data' => $question_array));
    }
  }

  $score = quiz_calculate_score($quiz, $result_id);
  if (!isset($score['percentage_score'])) {
    $score['percentage_score'] = 0;
  }
  $quiz_result->is_evaluated = $score['is_evaluated'];
  $quiz_result->score = $score['percentage_score'];
  $quiz_result->time_end = REQUEST_TIME;
  entity_save('quiz_result', $quiz_result);
  if ($user->uid) {
    $score['passing'] = quiz_is_passed($user->uid, $quiz->nid, $quiz->vid);
  }
  else {
    $score['passing'] = $score['percentage_score'] >= $quiz->pass_rate;
  }
  return $score;
}

/**
 * Actions to take at the end of a quiz
 *
 * @param $quiz
 *  The quiz node
 * @param $result_id
 *  Result id
 * @param $score
 *  Score as a number
 */
function quiz_end_actions($quiz, $score, $session_data) {
  // Call hook_quiz_finished().
  module_invoke_all('quiz_finished', $quiz, $score, $session_data);
}

/**
 * Implements hook_quiz_finished().
 *
 * Performs actions like sending quiz results over email at the end of quiz.
 */
function quiz_quiz_finished($quiz, $score, $session_data) {
  // @TODO convert to entity/rules
  $result_id = $session_data['result_id'];
  // Load data about the quiz taker
  $sql = 'SELECT u.uid, u.mail FROM {users} u JOIN {quiz_node_results} qnr ON u.uid = qnr.uid WHERE result_id = %d';
  $taker = db_query('SELECT u.uid, u.mail FROM {users} u JOIN {quiz_node_results} qnr ON u.uid = qnr.uid WHERE result_id = :result_id', array(':result_id' => $result_id))->fetch();

  if (variable_get('quiz_results_to_quiz_author', 0)) {
    $author_mail = db_query('SELECT mail FROM {users} WHERE uid = :uid', array(':uid' => $quiz->uid))->fetchField();
    drupal_mail('quiz', 'notice', $author_mail, NULL, array($quiz, $score, $result_id, 'author'));
  }

  if (variable_get('quiz_email_results', 0) && variable_get('quiz_use_passfail', 1) && $taker->uid != 0 && $score['is_evaluated']) {
    drupal_mail('quiz', 'notice', $taker->mail, NULL, array($quiz, $score, $result_id, 'taker'));
    drupal_set_message(t('Your results have been sent to your email address.'));
  }

  // Calls userpoints functions to credit user point based on number of correct
  // answers.
  if ($quiz->has_userpoints && $taker->uid != 0 && $score['is_evaluated']) {

    //Looking up the tid of the selected Userpoint vocabulary
    $selected_tid = db_query("SELECT tid FROM {taxonomy_index}
                WHERE nid = :nid AND tid IN (
                  SELECT tid
                  FROM {taxonomy_term_data} t_t_d JOIN {taxonomy_vocabulary} t_v ON t_v.vid = t_t_d.vid
                  WHERE t_t_d.vid = :vid
                )", array(':nid' => $quiz->nid, ':vid' => $quiz->vid, ':vid' => userpoints_get_vid()))->fetchField();
    $variables = array(
      '@title' => $quiz->title,
      '@quiz' => QUIZ_NAME,
      '@time' => date('l jS \of F Y h:i:s A'),
    );
    $params = array(
      'points' => $score['numeric_score'],
      'description' => t('Attended @title @quiz on @time', $variables),
      'tid' => $selected_tid,
      'uid' => $taker->uid,
    );
    if ($quiz->userpoints_tid != 0) {
      $params['tid'] = $quiz->userpoints_tid;
    }
    userpoints_userpointsapi($params);
  }
}

/**
 * Implements hook_quiz_scored().
 *
 * Performs actions like sending quiz results over email at the end of quiz.
 */
function quiz_quiz_scored($quiz, $score, $result_id) {
  // @TODO Rules
  $taker = db_query('SELECT u.uid, u.mail FROM {users} u JOIN {quiz_node_results} qnr ON u.uid = qnr.uid WHERE result_id = :rid', array(':rid' => $result_id))->fetch();
  if (variable_get('quiz_email_results', 0) && $taker->uid != 0 && $score['is_evaluated']) {
    drupal_mail('quiz', 'notice', $taker->mail, NULL, array($quiz, $score, $result_id, 'taker'));
    drupal_set_message(t("The results has been sent to the user's email address."));
  }

  // Calls userpoints functions to credit user point based on number of correct
  // answers.
  if ($quiz->has_userpoints && $taker->uid != 0 && $score['is_evaluated']) {

    //Looking up the tid of the selected Userpoint vocabulary
    $selected_tid = db_query("SELECT ti.tid
                FROM {taxonomy_index} ti
                JOIN {taxonomy_term_data} td
                  ON td.tid = ti.tid AND td.vid = :vid
                WHERE ti.nid = :nid", array(':nid' => $quiz->nid, ':vid' => userpoints_get_vid()))->fetchField();
    $variables = array(
      '@title' => $quiz->title,
      '@quiz' => QUIZ_NAME,
      '@time' => date('l jS \of F Y h:i:s A'),
    );
    $params = array(
      'points' => $score['numeric_score'],
      'description' => t('Attended @title @quiz on @time', $variables),
      'tid' => $selected_tid,
    );
    if ($quiz->userpoints_tid != 0) {
      $params['tid'] = $quiz->userpoints_tid;
    }
    userpoints_userpointsapi($params);
  }
}

/**
 * Implements hook_mail().
 */
function quiz_mail($key, &$message, $params) {
  global $user;

  switch ($key) {
    case 'notice':
      list($quiz, $score, $result_id, $target) = $params;
      $quiz_body = field_get_items('node', $quiz, 'body');
      $substitutions = array(
        '!title' => $quiz->title,
        '!sitename' => variable_get('site_name', 'Quiz'),
        '!taker' => $user->name,
        '!author' => $quiz->name,
        '!title' => check_plain($quiz->title),
        '!date' => format_date(REQUEST_TIME),
        '!desc' => $quiz_body ? $quiz_body[0]['value'] : '',
        '!correct' => isset($score['numeric_score']) ? $score['numeric_score'] : 0,
        '!total' => $score['possible_score'],
        '!percentage' => $score['percentage_score'],
        '!url' => url("user/{$user->uid}/quiz-results/{$result_id}/view", array('absolute' => TRUE)),
        '!minutes' => db_query("SELECT CEIL((time_end - time_start)/60) FROM {quiz_node_results} WHERE result_id = :result_id AND time_end", array(':result_id' => $result_id))->fetchField()
      );
      $type = $target != 'author' ? '_taker' : '';
      $test = variable_get('quiz_email_results_body' . $type, quiz_email_results_format('body', $target));
      $message['subject'] = t(variable_get('quiz_email_results_subject' . $type, quiz_email_results_format('subject', $target)), $substitutions, array('langcode' => $user->language));
      $message['body'][] = t($test, $substitutions, array('langcode' => $user->language));
  }
}

/**
 * This functions returns the default email subject and body format which will
 * be used at the end of quiz.
 */
function quiz_email_results_format($type, $target) {
  global $user;
  if ($type == 'subject') {
    if ($target == 'author') {
      return t('!title Results Notice from !sitename');
    }
    if ($target == 'taker') {
      return t('!title Results Notice from !sitename');
    }
  }
  if ($type == 'body') {
    if ($target == 'author') {
      return t('Dear !author') . "\n\n" .
        t('!taker attended the @quiz !title on !date', array('@quiz' => QUIZ_NAME)) . "\n" .
        t('Test Description : !desc') . "\n" .
        t('!taker got !correct out of !total points in !minutes minutes. Score given in percentage is !percentage') . "\n" .
        t('You can access the result here !url') . "\n";
    }
    if ($target == 'taker') {
      return t('Dear !taker') . "\n\n" .
        t('You attended the @quiz !title on !date', array('@quiz' => QUIZ_NAME)) . "\n" .
        t('Test Description : !desc') . "\n" .
        t('You got !correct out of !total points in !minutes minutes. Score given in percentage is !percentage') . "\n" .
        t('You can access the result here !url') . "\n";
    }
  }
}

/**
 * Update a score for a quiz.
 *
 * This updates the quiz node results table.
 *
 * It is used in cases where a quiz score is changed after the quiz has been
 * taken. For example, if a long answer question is scored later by a human,
 * then the quiz should be updated when that answer is scored.
 *
 * Important: The value stored in the table is the *percentage* score.
 *
 * @param $quiz
 *   The quiz node for the quiz that is being scored.
 * @param $result_id
 *   The result ID to update.
 * @return
 *   The score as an integer representing percentage. E.g. 55 is 55%.
 */
function quiz_update_total_score($quiz, $result_id) {
  $score = quiz_calculate_score($quiz, $result_id);
  db_update('quiz_node_results')
    ->fields(array(
      'score' => $score['percentage_score'],
    ))
    ->condition('result_id', $result_id)
    ->execute();
  if ($score['is_evaluated']) {
    // Call hook_quiz_scored().
    module_invoke_all('quiz_scored', $quiz, $score, $result_id);
    _quiz_maintain_results($quiz, $result_id);
    db_update('quiz_node_results')
      ->fields(array('is_evaluated' => 1))
      ->condition('result_id', $result_id)
      ->execute();
  }
  return $score['percentage_score'];
}

/**
 * Updates the max_score property on the specified quizzes
 *
 * @param $quizzes_to_update
 *  Array with the vid's of the quizzes to update
 */
function quiz_update_max_score_properties($quizzes_to_update) {
  if (empty($quizzes_to_update)) {
    return;
  }

  db_update('quiz_node_properties')
    ->expression('max_score', 'max_score_for_random * number_of_random_questions + (
      SELECT COALESCE(SUM(max_score), 0)
      FROM {quiz_node_relationship} qnr
      WHERE qnr.question_status = ' . QUESTION_ALWAYS . '
      AND parent_vid = {quiz_node_properties}.vid)')
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  db_update('quiz_node_properties')
    ->expression('max_score', '(SELECT COALESCE(SUM(qt.max_score * qt.number), 0)
      FROM {quiz_terms} qt
      WHERE qt.nid = {quiz_node_properties}.nid AND qt.vid = {quiz_node_properties}.vid)')
    ->condition('randomization', 3)
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  db_update('node_revision')
    ->fields(array('timestamp' => REQUEST_TIME))
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  db_update('node')
    ->fields(array('changed' => REQUEST_TIME))
    ->condition('vid', $quizzes_to_update, 'IN')
    ->execute();

  $results_to_update = db_query('SELECT vid FROM {quiz_node_properties} WHERE vid IN (:vid) AND max_score <> :max_score', array(':vid' => $quizzes_to_update, ':max_score' => 0))->fetchCol();
  if (!empty($results_to_update)) {
    db_update('quiz_node_results')
      ->expression('score', 'ROUND(
        100 * (
          SELECT COALESCE (SUM(a.points_awarded), 0)
          FROM {quiz_node_results_answers} a
          WHERE a.result_id = {quiz_node_results}.result_id
        ) / (
          SELECT max_score
          FROM {quiz_node_properties} qnp
          WHERE qnp.vid = {quiz_node_results}.vid
        )
      )')
      ->condition('vid', $results_to_update, 'IN')
      ->execute();
  }
}

/**
 * Check a user/quiz combo to see if the user passed the given quiz.
 *
 * This will return TRUE if the user has passed the quiz at least once, and
 * FALSE otherwise. Note that a FALSE may simply indicate that the user has not
 * taken the quiz.
 *
 * @param $uid
 *   The user ID.
 * @param $nid
 *   The node ID.
 * @param $vid
 *   The version ID.
 */
function quiz_is_passed($uid, $nid, $vid) {
  $passed = db_query('SELECT COUNT(result_id) AS passed_count FROM {quiz_node_results} qnrs
    INNER JOIN {quiz_node_properties} USING (vid, nid)
    WHERE qnrs.vid = :vid
      AND qnrs.nid = :nid
      AND qnrs.uid = :uid
      AND score >= pass_rate', array(':vid' => $vid, ':nid' => $nid, ':uid' => $uid))->fetchField();
  // Force into boolean context.
  return ($passed !== FALSE && $passed > 0);
}

/**
 * Actions to take place at the start of a quiz.
 *
 * This is called when the quiz node is viewed for the first time. It ensures
 * that the quiz can be taken at this time.
 *
 * @param $quiz
 *   The quiz node.
 *
 * @return
 *   Return quiz_node_results result_id, or FALSE if there is an error.
 */
function quiz_start_check($quiz) {
  global $user;

  $user_is_admin = node_access('update', $quiz);

  // Make sure this is available.
  if ($quiz->quiz_always != 1) {
    // Compare current GMT time to the open and close dates (which should still
    // be in GMT time).
    $now = REQUEST_TIME;

    if ($now >= $quiz->quiz_close || $now < $quiz->quiz_open) {
      if ($user_is_admin) {
        drupal_set_message(t('You are marked as an administrator or owner for this @quiz. While you can take this @quiz, the open/close times prohibit other users from taking this @quiz.', array('@quiz' => QUIZ_NAME)), 'status');
      }
      else {
        drupal_set_message(t('This @quiz is not currently available.', array('@quiz' => QUIZ_NAME)), 'status');
        // Can't take quiz.
        return FALSE;
      }
    }
  }

  // Check to see if this user is allowed to take the quiz again:
  if ($quiz->takes > 0) {
    $taken = db_query("SELECT COUNT(*) AS takes FROM {quiz_node_results} WHERE uid = :uid AND nid = :nid", array(':uid' => $user->uid, ':nid' => $quiz->nid))->fetchField();
    $allowed_times = format_plural($quiz->takes, '1 time', '@count times');
    $taken_times = format_plural($taken, '1 time', '@count times');

    // The user has already taken this quiz.
    if ($taken) {
      if ($user_is_admin) {

        drupal_set_message(t('You have taken this @quiz already. You are marked as an owner or administrator for this quiz, so you can take this quiz as many times as you would like.', array('@quiz' => QUIZ_NAME)), 'status');
      }
      // If the user has already taken this quiz too many times, stop the user.
      elseif ($taken >= $quiz->takes) {
        drupal_set_message(t('You have already taken this @quiz @really. You may not take it again.', array('@quiz', QUIZ_NAME, '@really' => $taken_times)), 'error');
        return FALSE;
      }
      // If the user has taken the quiz more than once, see if we should report
      // this.
      elseif ($quiz->show_attempt_stats) {
        drupal_set_message(t("You can only take this @quiz @allowed. You have taken it @really.", array('@quiz' => QUIZ_NAME, '@allowed' => $allowed_times, '@really' => $taken_times)), 'status');
      }
    }
  }

  // Check to see if the user is registered, and user alredy passed this quiz.
  if ($quiz->show_passed && $user->uid && quiz_is_passed($user->uid, $quiz->nid, $quiz->vid)) {
    drupal_set_message(t('You have already passed this @quiz.', array('@quiz' => QUIZ_NAME)), 'status');
  }

  return TRUE;
}

/**
 * Find out if a quiz is available for taking or not
 *
 * @param $quiz
 *  The quiz node
 * @return
 *  TRUE if available
 *  Error message(String) if not available
 */
function quiz_availability($quiz) {
  global $user;

  if ($user->uid == 0 && $quiz->takes > 0) {
    return t('This @quiz only allows %num_attempts attempts. Anonymous users can only access quizzes that allows an unlimited number of attempts.', array('%num_attempts' => $quiz->takes, '@quiz' => QUIZ_NAME));
  }

  $user_is_admin = user_access('edit any quiz content') || (user_access('edit own quiz content') && $quiz->uid == $user->uid);
  if ($user_is_admin || $quiz->quiz_always == 1) {
    return TRUE;
  }

  // Compare current GMT time to the open and close dates (which should still be
  // in GMT time).
  $now = REQUEST_TIME;

  if ($now >= $quiz->quiz_close || $now < $quiz->quiz_open) {
    return t('This @quiz is closed.', array('@quiz' => QUIZ_NAME));
  }
  return TRUE;
}

/**
 * Creates a unique id to be used when storing results for a quiz taker.
 *
 * @param $quiz
 *   The quiz node.
 * @return $result_id
 *   The result id.
 */
function quiz_create_rid($quiz) {
  $result_id = db_insert('quiz_node_results')
    ->fields(array(
      'nid' => $quiz->nid,
      'vid' => $quiz->vid,
      'uid' => $GLOBALS['user']->uid,
      'time_start' => REQUEST_TIME,
    ))
    ->execute();
  if (!is_numeric($result_id)) {
    form_set_error(t('There was a problem starting the @quiz. Please try again later.', array('@quiz' => QUIZ_NAME), array('langcode' => 'error')));
    return FALSE;
  }
  return $result_id;
}

/**
 * Calculates the score user received on quiz.
 *
 * @param $quiz
 *   The quiz node.
 * @param $result_id
 *   Quiz result ID.
 *
 * @return array
 *   Contains three elements: question_count, num_correct and percentage_score.
 */
function quiz_calculate_score($quiz, $result_id) {
  // 1. Fetch all questions and their max scores
  $questions = db_query('SELECT a.question_nid, a.question_vid, n.type, r.max_score
    FROM {quiz_node_results_answers} a
    LEFT JOIN {node} n ON (a.question_nid = n.nid)
    LEFT OUTER JOIN {quiz_node_relationship} r ON (r.child_vid = a.question_vid) AND r.parent_vid = :vid
    WHERE result_id = :rid', array(':vid' => $quiz->vid, ':rid' => $result_id));
  // 2. Callback into the modules and let them do the scoring. @todo after 4.0: Why isn't the scores already saved? They should be
  // Fetched from the db, not calculated....
  $scores = array();
  $count = 0;
  foreach ($questions as $question) {
    // Questions picked from term id's won't be found in the quiz_node_relationship table
    if ($question->max_score === NULL && isset($quiz->tid) && $quiz->tid > 0) {
      $question->max_score = $quiz->max_score_for_random;
    }

    // Invoke hook_quiz_question_score().
    // We don't use module_invoke() because (1) we don't necessarily want to wed
    // quiz type to module, and (2) this is more efficient (no NULL checks).
    $mod = quiz_question_module_for_type($question->type);
    if (!$mod) {
      continue;
    }
    $function = $mod . '_quiz_question_score';

    if (function_exists($function)) {
      $score = $function($quiz, $question->question_nid, $question->question_vid, $result_id);
      // Allow for max score to be considered.
      $scores[] = $score;
    }
    else {
      drupal_set_message(t('A @quiz question could not be scored: No scoring info is available', array('@quiz' => QUIZ_NAME)), 'error');
      $dummy_score = new stdClass();
      $dummy_score->possible = 0;
      $dummy_score->attained = 0;
      $scores[] = $dummy_score;
    }
    ++$count;
  }
  // 3. Sum the results.
  $possible_score = 0;
  $total_score = 0;
  $is_evaluated = TRUE;
  foreach ($scores as $score) {
    $possible_score += $score->possible;
    $total_score += $score->attained;
    if (isset($score->is_evaluated)) {
      // Flag the entire quiz if one question has not been evaluated.
      $is_evaluated &= $score->is_evaluated;
    }
  }

  // 4. Return the score.
  return array(
    'question_count' => $count,
    'possible_score' => $possible_score,
    'numeric_score' => $total_score,
    'percentage_score' => ($possible_score == 0) ? 0 : round(($total_score * 100) / $possible_score),
    'is_evaluated' => $is_evaluated,
  );
}

/**
 * @param $type
 *
 * @return string
 *   Name of module matching the question type, as given by quiz_question_info()
 *   hook.
 */
function quiz_question_module_for_type($type) {
  $types = quiz_get_question_types();
  if (!isset($types[$type])) {
    drupal_set_message(t('The module for the questiontype %type is not enabled', array('%type' => $type)), 'warning');
    return FALSE;
  }
  return $types[$type]['module'];
}

/**
 * Retrieves a list of questions (to be taken) for a given quiz.
 *
 * If the quiz has random questions this function only returns a random
 * selection of those questions. This function should be used to decide
 * what questions a quiz taker should answer.
 *
 * This question list is stored in the user's result, and may be different
 * when called multiple times. It should only be used to generate the layout
 * for a quiz attempt and NOT used to do operations on the questions inside of
 * a quiz.
 *
 * @param $quiz
 *   Quiz node.
 * @return
 *   Array of question node IDs.
 */
function quiz_build_question_list($quiz) {
  $questions = array();

  if ($quiz->randomization == 3) {
    $questions = _quiz_build_categorized_question_list($quiz);
  }
  else {
    // Get required questions first.
    $query = db_query('SELECT qnr.child_nid as nid, qnr.child_vid as vid, n.type, qnr.qnr_id, qnr.qnr_pid
    FROM {quiz_node_relationship} qnr
    JOIN {node} n ON qnr.child_nid = n.nid
    LEFT JOIN {quiz_node_relationship} qnr2 ON (qnr.qnr_pid = qnr2.qnr_id OR (qnr.qnr_pid IS NULL AND qnr.qnr_id = qnr2.qnr_id))
    WHERE qnr.parent_vid = :parent_vid
    AND qnr.question_status = :question_status
    AND n.status = 1
    ORDER BY qnr2.weight, qnr.weight', array(':parent_vid' => $quiz->vid, ':question_status' => QUESTION_ALWAYS));
    $i = 0;
    while ($question_node = $query->fetchAssoc()) {
      // Just to make it easier on us, let's use a 1-based index.
      $i++;
      $questions[$i] = $question_node;
    }

    // Get random questions for the remainder.
    if ($quiz->number_of_random_questions > 0) {
      $random_questions = _quiz_get_random_questions($quiz);
      $questions = array_merge($questions, $random_questions);
      if ($quiz->number_of_random_questions > count($random_questions)) {
        // Unable to find enough requested random questions.
        return FALSE;
      }
    }

    // Shuffle questions if required.
    if ($quiz->randomization > 0) {
      shuffle($questions);
    }
  }

  $count = 0;
  $display_count = 0;
  $questions_out = array();
  foreach ($questions as &$question) {
    $question_node = node_load($question['nid'], $question['vid']);
    $count++;
    $display_count++;
    $question['number'] = $count;
    if ($question['type'] != 'quiz_page') {
      $question['display_number'] = $display_count;
    }
    $questions_out[$count] = $question;
  }
  return $questions_out;
}

/**
 * Builds the questionlist for quizzes with categorized random questions
 *
 * @see quiz_build_question_list()
 */
function _quiz_build_categorized_question_list($quiz) {
  $terms = _quiz_get_terms($quiz->vid);
  $questions = array();
  $nids = array();
  $question_types = array_keys(quiz_get_question_types());
  if (empty($question_types)) {
    return array();
  }
  $total_count = 0;
  foreach ($terms as $term) {

    $query = db_select('node', 'n');
    $query->join('taxonomy_index', 'tn', 'n.nid = tn.nid');
    $query->fields('n', array('nid', 'vid'));
    $query->fields('tn', array('tid'));
    $query->condition('n.status', 1, '=');
    $query->condition('n.type', $question_types, 'IN');
    $query->condition('tn.tid', $term->tid, '=');
    if (!empty($nids)) {
      $query->condition('n.nid', $nids, 'NOT IN');
    }
    $query->range(0, $term->number);
    $query->orderBy('RAND()');

    $result = $query->execute();
    $count = 0;
    while ($question = $result->fetchAssoc()) {
      $count++;
      $question['tid'] = $term->tid;
      $question['number'] = $count + $total_count;
      $questions[] = $question;
      $nids[] = $question['nid'];
    }
    $total_count += $count;
    if ($count < $term->number) {
      // Not enough questions
      return array();
    }
  }
  return $questions;
}

/**
 * Get data for all terms belonging to a Quiz with categorized random questions
 *
 * @param int $vid
 *  version id for the quiz
 * @return array
 *  Array with all terms that belongs to the quiz as objects
 */
function _quiz_get_terms($vid) {
  $sql = 'SELECT td.name, qt.*
    FROM {quiz_terms} qt
    JOIN {taxonomy_term_data} td ON qt.tid = td.tid
    WHERE qt.vid = :vid
    ORDER BY qt.weight';
  return db_query($sql, array(':vid' => $vid))->fetchAll();
}

/**
 * Map node properties to a question object.
 *
 * @param $node
 *  The question node.
 *
 * @return
 *  Question object.
 */
function quiz_node_map($node) {
  $new_question = node_load($node->nid, $node->vid);
  // Append extra fields.
  $new_question->latest_vid = $node->latest_vid;
  $new_question->question_status = isset($node->question_status) ? $node->question_status : QUESTION_NEVER;
  if (isset($node->max_score)) {
    $new_question->max_score = $node->max_score;
  }
  if (isset($node->auto_update_max_score)) {
    $new_question->auto_update_max_score = $node->auto_update_max_score;
  }
  $new_question->weight = $node->weight;
  $new_question->qnr_id = $node->qnr_id;
  $new_question->qnr_pid = $node->qnr_pid;
  return $new_question;
}

/**
 * Sets the questions that are assigned to a quiz.
 *
 * @param $quiz
 *   The quiz(node) to modify.
 * @param $questions
 *   An array of questions.
 * @param $set_new_revision
 *   If TRUE, a new revision will be generated. Note that saving
 *   quiz questions unmodified will still generate a new revision of the quiz if
 *   this is set to TRUE. Why? For a few reasons:
 *   - All of the questions are updated to their latest VID. That is supposed to
 *     be a feature.
 *   - All weights are updated.
 *   - All status flags are updated.
 *
 * @return
 *   Boolean TRUE if update was successful, FALSE otherwise.
 */
function quiz_set_questions(&$quiz, $questions, $set_new_revision = FALSE) {
  if ($set_new_revision) {
    // Create a new Quiz VID, even if nothing changed.
    $quiz->revision = 1;

    node_save($quiz);
  }

  // When node_save() calls all of the node API hooks, old quiz info is
  // automatically inserted into quiz_node_relationship. We could get clever and
  // try to do strategic updates/inserts/deletes, but that method has already
  // proven error prone as the module has gained complexity (See 5.x-2.0-RC2).
  // So we go with the brute force method:
  db_delete('quiz_node_relationship')
    ->condition('parent_nid', $quiz->nid)
    ->condition('parent_vid', $quiz->vid)
    ->execute();

  if (empty($questions)) {
    return TRUE; // This is not an error condition.
  }

  foreach ($questions as $question) {
    if ($question->state != QUESTION_NEVER) {
      $question_inserts[$question->qnr_id] = array(
        'parent_nid' => $quiz->nid,
        'parent_vid' => $quiz->vid,
        'child_nid' => $question->nid,
        // Update to latest OR use the version given.
        'child_vid' => $question->refresh ? db_query('SELECT vid FROM {node} WHERE nid = :nid', array(':nid' => $question->nid))->fetchField() : $question->vid,
        'question_status' => $question->state,
        'weight' => $question->weight,
        'max_score' => (int) $question->max_score,
        'auto_update_max_score' => (int) $question->auto_update_max_score,
        'qnr_pid' => $question->qnr_pid,
        'qnr_id' => !$set_new_revision ? $question->qnr_id : NULL,
        'old_qnr_id' => $question->qnr_id,
      );
      drupal_write_record('quiz_node_relationship', $question_inserts[$question->qnr_id]);
    }
  }

  // Update the parentage when a new revision is created.
  // @todo this is copy pasta from quiz_update_quiz_question_relationship
  foreach ($question_inserts as $question_insert) {
    db_update('quiz_node_relationship')
      ->condition('qnr_pid', $question_insert['old_qnr_id'])
      ->condition('parent_vid', $quiz->vid)
      ->condition('parent_nid', $quiz->nid)
      ->fields(array('qnr_pid' => $question_insert['qnr_id']))
      ->execute();
  }

  quiz_update_max_score_properties(array($quiz->vid));
  return TRUE;
}

/**
 * @} End of "defgroup quiz_public".
 */

/**
 * Returns the result ID for any current result set for the given quiz.
 *
 * @param $uid
 *   User ID
 * @param $nid
 *   Quiz node ID
 * @param $vid
 *   Quiz node version ID
 * @param $now
 *   Timestamp used to check whether the quiz is still open. Default: current
 *   time.
 *
 * @return
 *   If a quiz is still open and the user has not finished the quiz,
 *   return the result set ID so that the user can continue. If no quiz is in
 *   progress, this will return 0.
 */
function _quiz_active_result_id($uid, $nid, $vid, $now = NULL) {
  if (!isset($now)) {
    $now = REQUEST_TIME;
  }

  // Get any quiz that is open, for this user, and has not already
  // been completed.
  $result_id = db_query('SELECT result_id FROM {quiz_node_results} qnr
          INNER JOIN {quiz_node_properties} qnp ON qnr.vid = qnp.vid
          WHERE (qnp.quiz_always = :quiz_always OR (:between BETWEEN qnp.quiz_open AND qnp.quiz_close))
          AND qnr.vid = :vid
          AND qnr.uid = :uid
          AND qnr.time_end IS NULL', array(':quiz_always' => 1, ':between' => $now, ':vid' => $vid, ':uid' => $uid))->fetchField();
  return (int) $result_id;
}

/**
 * Insert call specific to result options.
 *
 * This is called by quiz_insert().
 *
 * @param $node
 *   The quiz node.
 */
function _quiz_insert_resultoptions($node) {
  if (!isset($node->resultoptions)) {
    return;
  }

  $query = db_insert('quiz_node_result_options')
    ->fields(array('nid', 'vid', 'option_name', 'option_summary', 'option_summary_format', 'option_start', 'option_end'));

  foreach ($node->resultoptions as $id => $option) {
    if (!empty($option['option_name'])) {
      // When this function called direct from node form submit the $option['option_summary']['value'] and $option['option_summary']['format'] are we need
      // But when updating a quiz node eg. on manage questions page, this values come from loaded node, not from a submitted form.
      if (is_array($option['option_summary'])) {
        $option['option_summary_format'] = $option['option_summary']['format'];
        $option['option_summary'] = $option['option_summary']['value'];
      }
      $query->values(array(
        'nid' => $node->nid,
        'vid' => $node->vid,
        'option_name' => $option['option_name'],
        'option_summary' => $option['option_summary'],
        'option_summary_format' => $option['option_summary_format'],
        'option_start' => $option['option_start'],
        'option_end' => $option['option_end']
      ));
    }
  }

  $query->execute();
}

/**
 * Modify result of option-specific updates.
 *
 * @param $node
 *   The quiz node.
 */
function _quiz_update_resultoptions($node) {
  // Brute force method. Easier to get correct, and probably faster as well.
  db_delete('quiz_node_result_options')
    ->condition('vid', $node->vid)
    ->execute();
  _quiz_insert_resultoptions($node);
}

/**
 * Get the summary message for a completed quiz.
 *
 * Summary is determined by whether we are using the pass / fail options, how
 * the user did, and where the method is called from.
 *
 * @todo Need better feedback for when a user is viewing their quiz results
 *   from the results list (and possibily when revisiting a quiz they can't take
 *   again).
 *
 * @param $quiz
 *   The quiz node object.
 * @param $score
 *   The score information as returned by quiz_calculate_score().
 * @return
 *   Filtered summary text or null if we are not displaying any summary.
 */
function _quiz_get_summary_text($quiz, $score) {
  $summary = array();
  $admin = (arg(0) == 'admin');
  $quiz_format = (isset($quiz->body[LANGUAGE_NONE][0]['format'])) ? $quiz->body[LANGUAGE_NONE][0]['format'] : NULL;
  if (!$admin) {
    if (!empty($score['result_option'])) {
      // Unscored quiz, return the proper result option.
      $summary['result'] = check_markup($score['result_option'], $quiz_format);
    }
    else {
      $result_option = _quiz_pick_result_option($quiz->nid, $quiz->vid, $score['percentage_score']);
      $summary['result'] = is_object($result_option) ? check_markup($result_option->option_summary, $result_option->option_summary_format) : '';
    }
  }

  // If we are using pass/fail, and they passed.
  if ($quiz->pass_rate > 0 && $score['percentage_score'] >= $quiz->pass_rate) {
    // If we are coming from the admin view page.
    if ($admin) {
      $summary['passfail'] = t('The user passed this @quiz.', array('@quiz' => QUIZ_NAME));
    }
    elseif (variable_get('quiz_use_passfail', 1) == 0) {
      // If there is only a single summary text, use this.
      if (trim($quiz->summary_default) != '') {
        $summary['passfail'] = check_markup($quiz->summary_default, $quiz_format);
      }
    }
    elseif (trim($quiz->summary_pass) != '') {
      // If there is a pass summary text, use this.
      $summary['passfail'] = check_markup($quiz->summary_pass, $quiz->summary_pass_format);
    }
  }
  // If the user did not pass or we are not using pass/fail.
  else {
    // If we are coming from the admin view page, only show a summary if we are
    // using pass/fail.
    if ($admin) {
      if ($quiz->pass_rate > 0) {
        $summary['passfail'] = t('The user failed this @quiz.', array('@quiz' => QUIZ_NAME));
      }
      else {
        $summary['passfail'] = t('the user completed this @quiz.', array('@quiz' => QUIZ_NAME));
      }
    }
    elseif (trim($quiz->summary_default) != '') {
      $summary['passfail'] = check_markup($quiz->summary_default, $quiz->summary_default_format);
    }
  }
  return $summary;
}

/**
 * Get summary text for a particular score from a set of result options.
 *
 * @param $qnid
 *   The quiz node id.
 * @param $qvid
 *   The quiz node revision id.
 * @param $score
 *   The user's final score.
 *
 * @return
 *   Summary text for the user's score.
 */
function _quiz_pick_result_option($qnid, $qvid, $score) {
  return db_query('SELECT option_summary, option_summary_format FROM {quiz_node_result_options}
      WHERE nid = :nid AND vid = :vid AND :option BETWEEN option_start AND option_end', array(':nid' => $qnid, ':vid' => $qvid, ':option' => $score)
    )->fetch();
}

/**
 * Get an array list of random questions for a quiz.
 *
 * @param $quiz
 *   The quiz node.
 *
 * @return
 *   Array of nid/vid combos for quiz questions.
 */
function _quiz_get_random_questions($quiz) {
  $num_random = $quiz->number_of_random_questions;
  $tid = $quiz->tid;
  $questions = array();
  if ($num_random > 0) {
    if ($tid > 0) {
      $questions = _quiz_get_random_taxonomy_question_ids($tid, $num_random);
    }
    else {
      // Select random question from assigned pool.
      $result = db_query_range(
        "SELECT child_nid as nid, child_vid as vid, n.type
        FROM {quiz_node_relationship} qnr
        JOIN {node} n on qnr.child_nid = n.nid
        WHERE qnr.parent_vid = :parent_vid
        AND qnr.parent_nid = :parent_nid
        AND qnr.question_status = :question_status
        AND n.status = 1
        ORDER BY RAND()", 0, $quiz->number_of_random_questions, array(
        ':parent_vid' => $quiz->vid,
        ':parent_nid' => $quiz->nid,
        ':question_status' => QUESTION_RANDOM
        )
      );
      while ($question_node = $result->fetchAssoc()) {
        $question_node['random'] = TRUE;
        $question_node['relative_max_score'] = $quiz->max_score_for_random;
        $questions[] = $question_node;
      }
    }
  }
  return $questions;
}

/**
 * Given a term ID, get all of the question nid/vids that have that ID.
 *
 * @param $tid
 *   Integer term ID.
 *
 * @return
 *   Array of nid/vid combos, like array(array('nid'=>1, 'vid'=>2)).
 */
function _quiz_get_random_taxonomy_question_ids($tid, $num_random) {
  if ($tid == 0) {
    return array();
  }

  // Select random questions by taxonomy.
  $term = taxonomy_term_load($tid);
  $tree = taxonomy_get_tree($term->vid, $term->tid);

  // Flatten the taxonomy tree, and just keep term id's.
  $term_ids[] = $term->tid;
  if (is_array($tree)) {
    foreach ($tree as $term) {
      $term_ids[] = $term->tid;
    }
  }
  $term_ids = implode(',', $term_ids);

  // Get all published questions with one of the allowed term ids.
  // TODO Please convert this statement to the D7 database API syntax.
  $result = db_query_range("SELECT n.nid, n.vid
    FROM {node} n
    INNER JOIN {taxonomy_index} tn USING (nid)
    WHERE n.status = 1 AND tn.tid IN ($term_ids)
    AND n.type IN ('" . implode("','", array_keys(quiz_get_question_types()))
    . "') ORDER BY RAND()");

  $questions = array();
  while ($question_node = db_fetch_array($result)) {
    $question_node['random'] = TRUE;
    $questions[] = $question_node;
  }

  return $questions;
}

/**
 * Retrieve list of question types.
 *
 * @return
 *  Array of question types.
 */
function quiz_get_question_types() {
  $quiz_questions = &drupal_static(__FUNCTION__);

  // We vastly improves performance by statically caching the question types.
  if (!empty($quiz_questions)) {
    return $quiz_questions;
  }

  // Get question types from the modules that defines them.
  if ($quiz_questions = module_invoke_all('quiz_question_info')) {
    return $quiz_questions;
  }

  drupal_set_message(t('You need to install and enable at least one question type(multichoice for instance) to use quiz.'), 'warning', FALSE);
  return array();
}

/**
 * Retrieve list of vocabularies for all quiz question types.
 *
 * @return
 *   An array containing a vocabulary list.
 */
function _quiz_get_vocabularies() {
  $vocabularies = array();
  $types = array_keys(quiz_get_question_types());
  foreach ($types as $type) {
    foreach (taxonomy_get_vocabularies($type) as $vid => $vocabulary) {
      $vocabularies[$vid] = $vocabulary;
    }
  }
  return $vocabularies;
}

/**
 * Prints a taxonomy selection form for each vocabulary.
 *
 * @param $value
 *   Default selected value(s).
 * @return
 *   HTML output to print to screen.
 */
function _quiz_taxonomy_select($value = 0) {
  $options = array();
  foreach (_quiz_get_vocabularies() as $vid => $vocabulary) {
    $temp = taxonomy_form($vid, $value);
    $options = array_merge($options, $temp['#options']);
  }
  return $options;
}

/**
 * Retrieve list of published questions assigned to quiz.
 *
 * This function should be used for question browsers and similiar... It should not be used to decide what questions
 * a user should answer when taking a quiz. quiz_build_question_list is written for that purpose.
 *
 * @param $quiz_nid
 *   Quiz node id.
 * @param $quiz_vid
 *   Quiz node version id.
 *
 * @return
 *   An array of questions.
 */
function quiz_get_questions($quiz_nid, $quiz_vid = NULL) {
  $questions = array();
  $query = db_select('node', 'n');
  $query->fields('n', array('nid', 'type'));
  $query->fields('nr', array('vid', 'title'));
  $query->fields('qnr', array('question_status', 'weight', 'max_score', 'auto_update_max_score', 'qnr_id', 'qnr_pid'));
  $query->addField('n', 'vid', 'latest_vid');
  $query->join('node_revision', 'nr', 'n.nid = nr.nid');
  $query->leftJoin('quiz_node_relationship', 'qnr', 'nr.vid = qnr.child_vid');
  $query->condition('n.status', 1);
  $query->condition('qnr.parent_nid', $quiz_nid);
  if ($quiz_vid) {
    $query->condition('qnr.parent_vid', $quiz_vid);
  }
  $query->condition('qnr_pid', NULL, 'IS');
  $query->orderBy('qnr.weight');

  $result = $query->execute();
  foreach ($result as $question) {
    $questions[] = $question;
    quiz_get_sub_questions($question->qnr_id, $questions);
  }

  foreach ($questions as &$node) {
    $node = quiz_node_map($node);
  }

  return $questions;
}

/**
 * Get sub-questions.
 */
function quiz_get_sub_questions($qnr_pid, &$questions) {
  $query = db_select('node', 'n');
  $query->fields('n', array('nid', 'type'));
  $query->fields('nr', array('vid', 'title'));
  $query->fields('qnr', array('question_status', 'weight', 'max_score', 'auto_update_max_score', 'qnr_id', 'qnr_pid'));
  $query->addField('n', 'vid', 'latest_vid');
  $query->innerJoin('node_revision', 'nr', 'n.nid = nr.nid');
  $query->innerJoin('quiz_node_relationship', 'qnr', 'nr.vid = qnr.child_vid');
  $query->condition('qnr_pid', $qnr_pid);
  $query->orderBy('weight');
  $result = $query->execute();
  foreach ($result as $question) {
    $questions[] = $question;
  }
}

/**
 * Get a list of all available quizzes.
 *
 * @param $uid
 *   An optional user ID. If supplied, only quizzes created by that user will be
 *   returned.
 *
 * @return
 *   A list of quizzes.
 */
function _quiz_get_quizzes($uid = 0) {
  $results = array();
  $args = array();
  $query = db_select('node', 'n')
    ->fields('n', array('nid', 'vid', 'title', 'uid', 'created'))
    ->fields('u', array('name'));
  $query->leftJoin('users', 'u', 'u.uid = n.uid');
  $query->condition('n.type', 'quiz');
  if ($uid != 0) {
    $query->condition('n.uid', $uid);
  }
  $query->orderBy('n.nid');
  $quizzes = $query->execute();
  foreach ($quizzes as $quiz) {
    $results[$quiz->nid] = (array) $quiz;
  }
  return $results;
}

/**
 * Get answer data for a specific result.
 *
 * @param $result_id
 *   Result id.
 *
 * @return
 *   Array of answers.
 */
function _quiz_get_answers($quiz, $result_id) {
  $questions = array();
  $ids = db_query("SELECT question_nid, question_vid, type, rs.max_score, qt.max_score as term_max_score
                   FROM {quiz_node_results_answers} ra
                   LEFT JOIN {node} n ON (ra.question_nid = n.nid)
                   LEFT JOIN {quiz_node_results} r ON (ra.result_id = r.result_id)
                   LEFT OUTER JOIN {quiz_node_relationship} rs ON (ra.question_vid = rs.child_vid) AND rs.parent_vid = r.vid
                   LEFT OUTER JOIN {quiz_terms} qt ON (qt.vid = :vid AND qt.tid = ra.tid)
                   WHERE ra.result_id = :rid
                   ORDER BY ra.number, ra.answer_timestamp", array(':vid' => $quiz->vid, ':rid' => $result_id));
  while ($line = $ids->fetch()) {
    // Questions picked from term id's won't be found in the quiz_node_relationship table
    if ($line->max_score === NULL) {
      if ($quiz->randomization == 2 && isset($quiz->tid) && $quiz->tid > 0) {
        $line->max_score = $quiz->max_score_for_random;
      }
      elseif ($quiz->randomization == 3) {
        $line->max_score = $line->term_max_score;
      }
    }
    $module = quiz_question_module_for_type($line->type);
    if (!$module) {
      continue;
    }
    // Invoke hook_get_report().
    $report = module_invoke($module, 'get_report', $line->question_nid, $line->question_vid, $result_id);
    if (!$report) {
      continue;
    }
    $questions[$line->question_nid] = $report;
    // Add max score info to the question.
    if (!isset($questions[$line->question_nid]->score_weight)) {
      if ($questions[$line->question_nid]->max_score == 0) {
        $score_weight = 0;
      }
      else {
        $score_weight = $line->max_score / $questions[$line->question_nid]->max_score;
      }
      $questions[$line->question_nid]->qnr_max_score = $line->max_score;
      $questions[$line->question_nid]->score_weight = $score_weight;
    }
  }
  return $questions;
}

/**
 * Get the quiz name variable and set it as a constant so we don't have to keep
 * calling it in every function.
 *
 * @return
 *   Quiz name variable.
 */
function _quiz_get_quiz_name() {
  return t(variable_get('quiz_name', 'Quiz'));
}

/**
 * This function was copied from the triggers module as to prevent having to be
 * dependent on that module for the actions to work.  The trigger function is
 * called trigger_options().
 *
 * @param $type
 *   One of 'node', 'user', 'comment'.
 *
 * @return
 *   Array keyed by action ID.
 */
function quiz_action_options($type = 'all') {
  $options = array(t('Choose an action'));
  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {
    $options[$action['type']][$aid] = $action['label'];
  }

  if ($type == 'all') {
    return $options;
  }
  else {
    $options[$type][0] = t('Choose an action');
    // Lets sort it to get the choose an action back first.
    ksort($options[$type]);
    return $options[$type];
  }
}

/**
 * Returns an array with quiz titles keyed with quiz node ids.
 *
 * @return array
 *   Options suitable for a form, in which the value is nid.
 */
function quiz_get_quiz_options() {
  $options = array();
  $results = db_query('SELECT n.nid, n.title, n.type FROM {node} n WHERE n.type = :type', array(':type' => 'quiz'));
  foreach ($results as $result) {
    $options[$result->nid] = drupal_substr(check_plain($result->title), 0, 30);
  }
  return $options;
}

/**
 * Tells whether a question node is being viewed inside/outside of quiz.
 *
 * @return
 *   Boolean.
 */
function _quiz_is_taking_context() {
  return arg(2) == 'take';
}

/**
 * Retrieves the quiz node from the menu router.
 *
 * @return
 *   Quiz node, if found, or FALSE if quiz node can't be retrieved from the menu
 *   router.
 */
function quiz_get_quiz_from_menu() {
  if ($to_return = menu_get_object('quiz_type_access', 4)) {
    return $to_return;
  }
  //TODO: FIX it. This seems to return NULL in feedback page.
  $node = menu_get_object();
  return (is_object($node) && $node->type == 'quiz') ? $node : FALSE;
}

/**
 * Finds out if a quiz has been answered or not.
 *
 * @return
 *   TRUE if there exists answers to the current question.
 */
function quiz_has_been_answered($node) {
  if (!isset($node->nid)) {
    return FALSE;
  }
  $query = db_select('quiz_node_results', 'qnr');
  $query->addField('qnr', 'result_id');
  $query->condition('nid', $node->nid);
  $query->condition('vid', $node->vid);
  $query->range(0, 1);
  return $query->execute()->rowCount() > 0;
}

/**
 * If a quiz is saved as not randomized we should make sure all random questions
 * are converted to always.
 *
 * @param $node
 *   Quiz node.
 */
function _quiz_check_num_random(&$node) {
  if ($node->randomization == 2) {
    return;
  }
  db_delete('quiz_node_relationship')
    ->condition('question_status', QUESTION_RANDOM)
    ->condition('parent_vid', $node->vid)
    ->execute();
}

/**
 * If a quiz is saved with random categories we should make sure all questions
 * are removed from the quiz
 *
 * @param $node
 *   Quiz node.
 */
function _quiz_check_num_always(&$node) {
  if ($node->randomization != 3) {
    return;
  }
  db_delete('quiz_node_relationship')
    ->condition('parent_vid', $node->vid)
    ->execute();
}

/**
 * Checks if the user has access to save score for his quiz.
 */
function quiz_allow_score_access($quiz, $account = NULL) {
  global $user;

  if ($account == NULL) {
    $account = $user;
  }

  if (user_access('score any quiz', $account)) {
    return true;
  }

  return user_access('score own quiz', $account) && ($quiz->uid == $account->uid);
}

/**
 * Determine who should have access to the My results tab.
 */
function _quiz_user_results_access($user_id) {
  global $user;
  return ($user_id == $user->uid && user_access('view own quiz results')) || user_access('view any quiz results');
}

/**
 * Copies questions when a quiz is translated.
 *
 * @param $node
 *   The new translated quiz node.
 */
function quiz_copy_questions($node) {
  // Find original questions.
  $query = db_query('SELECT child_nid, child_vid, question_status, weight, max_score, auto_update_max_score
    FROM {quiz_node_relationship}
    WHERE parent_vid = :parent_vid', array(':parent_vid' => $node->translation_source->vid));
  foreach ($query as $res_o) {
    $original_question = node_load($res_o->child_nid);

    // Set variables we can't or won't carry with us to the translated node to
    // NULL.
    $original_question->nid = $original_question->vid = $original_question->created = $original_question->changed = NULL;
    $original_question->revision_timestamp = $original_question->menu = $original_question->path = NULL;
    $original_question->files = array();
    if (isset($original_question->book['mlid'])) {
      $original_question->book['mlid'] = NULL;
    }

    // Set the correct language.
    $original_question->language = $node->language;

    // Save the node.
    node_save($original_question);

    // Save the relationship between the new question and the quiz.
    db_insert('quiz_node_relationship')
      ->fields(array(
        'parent_nid' => $node->nid,
        'parent_vid' => $node->vid,
        'child_nid' => $original_question->nid,
        'child_vid' => $original_question->vid,
        'question_status' => $res_o->question_status,
        'weight' => $res_o->weight,
        'max_score' => $res_o->max_score,
        'auto_update_max_score' => $res_o->auto_update_max_score,
      ))
      ->execute();
  }
}

/**
 * Deletes results for a quiz according to the keep results setting
 *
 * @param $quiz
 *  The quiz node to be maintained
 * @param $result_id
 *  The result id of the latest result for the current user
 * @return
 *  TRUE if results where deleted.
 */
function _quiz_maintain_results($quiz, $result_id) {
  global $user;

  // Do not delete results for anonymous users
  if ($user->uid == 0) {
    return;
  }

  switch ($quiz->keep_results) {
    case QUIZ_KEEP_ALL:
      return FALSE;
    case QUIZ_KEEP_BEST:
      $best_result_id = db_query('SELECT result_id FROM {quiz_node_results}
          WHERE nid = :nid AND uid = :uid AND is_evaluated = :is_evaluated
          ORDER BY score DESC', array(':nid' => $quiz->nid, ':uid' => $user->uid, ':is_evaluated' => 1)
        )
        ->fetchField();
      if (!$best_result_id) {
        return;
      }
      $res = db_query('SELECT result_id FROM {quiz_node_results}
          WHERE nid = :nid AND uid = :uid AND result_id != :best_rid AND is_evaluated = :is_evaluated', array(':nid' => $quiz->nid, ':uid' => $user->uid, ':is_evaluated' => 1, ':best_rid' => $best_result_id)
      );
      $result_ids = array();
      while ($result_id2 = $res->fetchField()) {
        $result_ids[] = $result_id2;
      }
      entity_delete_multiple('quiz_result', $result_ids);
      return !empty($result_ids);
    case QUIZ_KEEP_LATEST:
      $res = db_query('SELECT result_id FROM {quiz_node_results}
              WHERE nid = :nid AND uid = :uid AND is_evaluated = :is_evaluated AND result_id != :result_id', array(':nid' => $quiz->nid, ':uid' => $user->uid, ':is_evaluated' => 1, ':result_id' => $result_id));
      $result_ids = array();
      while ($result_id2 = $res->fetchField()) {
        $result_ids[] = $result_id2;
      }
      entity_delete_multiple('quiz_result', $result_ids);
      return !empty($result_ids);
  }
}

/**
 * Delete quiz results by ID.
 *
 * @param $result_ids
 *   Result ids for the results to be deleted.
 */
function quiz_delete_results($result_ids) {
  entity_delete_multiple('quiz_result', $result_ids);
}

/**
 * Implements hook_quiz_result_delete().
 */
function quiz_quiz_result_delete($quiz_result) {
  // Fire the question types' implementations of question attempts deletion.
  $sql = 'SELECT result_id, question_nid, question_vid FROM {quiz_node_results_answers}
          WHERE result_id = (:result_id)';
  $result = db_query($sql, array(':result_id' => $quiz_result->result_id));
  foreach ($result as $record) {
    quiz_question_delete_result($record->result_id, $record->question_nid, $record->question_vid);
  }

  // Delete Quiz's records of any attempts at a question.
  db_delete('quiz_node_results_answers')
    ->condition('result_id', $quiz_result->result_id)
    ->execute();
}

/**
 * Returns the users default settings.
 *
 * @param $node
 *   Quiz node.
 * @param $uid
 *   (optional) The uid of the user to get the settings for. Defaults to the
 *   current user (NULL).
 *
 * @return
 *   An array of settings. The array is empty in case no settings are available.
 */
function quiz_get_defaults() {
  global $user;

  $entity = entity_load('quiz_properties', FALSE, array(
    'uid' => $user->uid,
    'nid' => 0,
    'vid' => 0,
    ), TRUE);

  if (count($entity)) {
    // We found user defaults.
    $defaults = reset($entity);
    unset($defaults->nid, $defaults->uid, $defaults->vid);
    return $defaults;
  }

  $entity = entity_load('quiz_properties', FALSE, array(
    'uid' => 0,
    'nid' => 0,
    'vid' => 0,
    ), TRUE);

  if (count($entity)) {
    // Found global defaults.
    $defaults = reset($entity);
    unset($defaults->nid, $defaults->uid, $defaults->vid);
    return $defaults;
  }

  // No defaults set yet.
  return _quiz_get_node_defaults();
}

/**
 * Get the number of compulsory questions for a quiz.
 *
 * @param $nid
 *   Quiz node id.
 * @param $vid
 *   Quiz node version id.
 * @return
 *   Number of compulsory questions.
 */
function _quiz_get_num_always_questions($vid) {
  return db_query('SELECT COUNT(*) FROM {quiz_node_relationship} qnr
          JOIN {node} n ON n.nid = qnr.child_nid
          WHERE n.status=1 AND qnr.parent_vid = :parent_vid AND qnr.question_status = :question_status', array(':parent_vid' => $vid, ':question_status' => QUESTION_ALWAYS))->fetchField();
}

/**
 * Format a number of seconds to a hh:mm:ss format.
 *
 * @param $time_in_sec
 *   Integers time in seconds.
 *
 * @return
 *   String time in min : sec format.
 */
function _quiz_format_duration($time_in_sec) {
  $hours = intval($time_in_sec / 3600);
  $min = intval(($time_in_sec - $hours * 3600) / 60);
  $sec = $time_in_sec % 60;
  if (strlen($min) == 1) {
    $min = '0' . $min;
  }
  if (strlen($sec) == 1) {
    $sec = '0' . $sec;
  }
  return "$hours:$min:$sec";
}

/**
 * Helper function used when validating integers.
 *
 * @param $value
 *   The value to be validated.
 * @param $min
 *   The minimum value $value is allowed to be.
 * @param $max
 *   The maximum value $value is allowed to be.
 *
 * @return
 *   TRUE if integer in the allowed range. FALSE otherwise.
 */
function _quiz_is_int($value, $min = 1, $max = NULL) {
  $to_return = ((string) $value === (string) (int) $value);
  // $value is not an integer.
  if (!$to_return) {
    return FALSE;
  }
  // $value is too small.
  if ($value < $min) {
    return FALSE;
  }
  // $value is too big.
  if (isset($max)) {
    if ($value > $max) {
      return FALSE;
    }
  }
  // $value is an integer in the allowed range.
  return TRUE;
}

/**
 * Helper function used when validating plain text.
 *
 * @param $value
 *   The value to be validated.
 *
 * @return
 *   TRUE if plain text FALSE otherwise.
 */
function _quiz_is_plain($value) {
  return ($value === check_plain($value));
}

/**
 * Helper function used when figuring out if a textfield or textarea is empty.
 *
 * Solves a problem with some wysiwyg editors inserting spaces and tags without content.
 *
 * @param $html
 *   The html to evaluate
 *
 * @return
 *   TRUE if the field is empty(can still be tags there) false otherwise.
 */
function _quiz_is_empty_html($html) {
  return drupal_strlen(trim(str_replace('&nbsp;', '', strip_tags($html, '<img><object><embed>')))) == 0;
}

/**
 * Show the finish button?
 */
function _quiz_show_finish_button($quiz) {
  $quiz_result = quiz_result_load($_SESSION['quiz'][$quiz->nid]['result_id']);
  $current = $_SESSION['quiz'][$quiz->nid]['current'];
  foreach ($quiz_result->layout as $idx => $question) {
    if ($question['type'] == 'quiz_page') {
      if ($current == $idx) {
        // Found a page that we are on
        $in_page = TRUE;
        $last_page = TRUE;
      }
      else {
        // Found a quiz page that we are not on.
        $last_page = FALSE;
      }
    }
    else if (empty($question['qnr_pid'])) {
      // A question without a parent showed up.
      $in_page = FALSE;
      $last_page = FALSE;
    }
  }

  return $last_page || !isset($quiz_result->layout[$_SESSION['quiz'][$quiz->nid]['current'] + 1]);
}

/**
 * Implements hook_entity_info().
 */
function quiz_entity_info() {
  return array(
    'quiz_result' => array(
      'label' => t('Quiz result'),
      'controller class' => 'EntityAPIController',
      'base table' => 'quiz_node_results',
      'entity keys' => array(
        'id' => 'result_id',
      ),
      'views controller class' => 'EntityDefaultViewsController',
    ),
    'quiz_result_answer' => array(
      'label' => t('Quiz result answer'),
      'controller class' => 'EntityAPIController',
      'base table' => 'quiz_node_results_answers',
      'entity keys' => array(
        'id' => 'result_answer_id',
      ),
      'views controller class' => 'EntityDefaultViewsController',
    ),
    'quiz_question_relationship' => array(
      'label' => t('Quiz question relationship'),
      'controller class' => 'EntityAPIController',
      'base table' => 'quiz_node_relationship',
      'entity keys' => array(
        'id' => 'qnr_id',
      ),
      'views controller class' => 'EntityDefaultViewsController',
    ),
    'quiz_properties' => array(
      'label' => t('Quiz properties'),
      'controller class' => 'EntityAPIController',
      'base table' => 'quiz_node_properties',
      'entity keys' => array(
        'id' => 'qnp_id',
      ),
      'views controller class' => 'EntityDefaultViewsController',
    ),
  );
}

/**
 * Shortcut to entity_load_single().
 */
function quiz_result_load($result_id) {
  return entity_load_single('quiz_result', $result_id);
}

/**
 * Menu check to see if user has access to take this question.
 */
function quiz_access_question($quiz, $question_number) {
  if (!$question_number) {
    return FALSE;
  }

  if ($quiz->allow_jumping) {
    // Access to go to any question. Yay.
    return TRUE;
  }

  $result_id = $_SESSION['quiz'][$quiz->nid]['result_id'];
  $quiz_result = quiz_result_load($result_id);
  $question_index = $question_number;
  $qinfo_last = $question_number == 1 ? NULL : $quiz_result->layout[$question_index - 1];
  $qinfo = $quiz_result->layout[$question_index];
  $question_node = node_load($qinfo['nid'], $qinfo['vid']);
  $question_node_last = node_load($qinfo_last['nid'], $qinfo_last['vid']);

  if (!$quiz->backwards_navigation) {
    // No backwards navigation.
    if (quiz_result_is_question_answered($quiz_result, $question_node)) {
      // Already have an answer for the requested question.
      return FALSE;
    }
  }

  // Enforce normal navigation.
  if ($question_number == 1 || quiz_result_is_question_answered($quiz_result, $question_node_last)) {
    //  Previous answer was submitted or this is the first question.
    return TRUE;
  }
}

/**
 * Show feedback for a question response.
 */
function quiz_take_question_feedback($quiz, $question_number) {
  if (empty($_SESSION['quiz'][$quiz->nid]['result_id'])) {
    $result_id = $_SESSION['quiz']['temp']['result_id'];
  }
  else {
    $result_id = $_SESSION['quiz'][$quiz->nid]['result_id'];
  }
  $quiz_result = quiz_result_load($result_id);
  $question_node = node_load($quiz_result->layout[$question_number]['nid']);
  $feedback = quiz_question_feedback(node_load(arg(1)), $question_node);
  return $feedback;
}

/**
 * Submit handler to go to the next question from the question feedback.
 */
function quiz_take_question_feedback_submit($form, &$form_state) {
  $quiz = node_load(arg(1));
  $form_state['redirect'] = "node/{$quiz->nid}/take/" . $_SESSION['quiz'][$quiz->nid]['current'];
}

/**
 * Submit handler to go to the quiz results from the last question's feedback.
 */
function quiz_take_question_feedback_end_submit($form, &$form_state) {
  $quiz = node_load(arg(1));
  $result_id = $_SESSION['quiz']['temp']['result_id'];
  $form_state['redirect'] = "node/{$quiz->nid}/quiz-results/$result_id/view";
}

/**
 * Implements hook_entity_property_info_alter().
 *
 * Define our special schema fields and relationships.
 */
function quiz_entity_property_info_alter(&$info) {
  $info['quiz_question_relationship']['properties']['child_nid']['type'] = 'node';
  $info['quiz_question_relationship']['properties']['child_vid']['type'] = 'integer';
  $info['quiz_question_relationship']['properties']['parent_nid']['type'] = 'node';
  $info['quiz_question_relationship']['properties']['parent_vid']['type'] = 'integer';

  $info['quiz_result_answer']['properties']['result_id']['type'] = 'quiz_result';
  $info['quiz_result_answer']['properties']['question_nid']['type'] = 'node';
  $info['quiz_result_answer']['properties']['is_correct']['type'] = 'boolean';
  $info['quiz_result_answer']['properties']['is_skipped']['type'] = 'boolean';
  $info['quiz_result_answer']['properties']['is_doubtful']['type'] = 'boolean';
  $info['quiz_result_answer']['properties']['answer_timestamp']['type'] = 'date';

  $info['quiz_result']['properties']['nid']['type'] = 'node';
  $info['quiz_result']['properties']['vid']['type'] = 'integer';
  $info['quiz_result']['properties']['uid']['type'] = 'user';
  $info['quiz_result']['properties']['time_start']['label'] = 'Date started';
  $info['quiz_result']['properties']['time_start']['type'] = 'date';
  $info['quiz_result']['properties']['time_end']['label'] = 'Date finished';
  $info['quiz_result']['properties']['time_end']['type'] = 'date';
  $info['quiz_result']['properties']['released']['type'] = 'date';
  $info['quiz_result']['properties']['score']['label'] = 'Score';
  $info['quiz_result']['properties']['score']['type'] = 'integer';
  $info['quiz_result']['properties']['is_invalid']['label'] = 'Invalid';
  $info['quiz_result']['properties']['is_invalid']['type'] = 'boolean';
  $info['quiz_result']['properties']['is_evaluated']['label'] = 'Evaluated';
  $info['quiz_result']['properties']['is_evaluated']['type'] = 'boolean';
  $info['quiz_result']['properties']['time_left']['type'] = 'duration';

  $info['quiz']['properties']['quiz_open']['label'] = 'Open date';
  $info['quiz']['properties']['quiz_open']['type'] = 'date';
  $info['quiz']['properties']['quiz_close']['label'] = 'Close date';
  $info['quiz']['properties']['quiz_close']['type'] = 'date';
}

function quiz_jumper_form($form, $form_state, $questions, $current) {
  $form['question_number'] = array(
    '#type' => 'select',
    '#options' => $questions,
    '#default_value' => $current,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Jump'),
    '#attributes' => array('class' => array('js-hide')),
  );
  return $form;
}

function quiz_jumper_form_submit($form, &$form_state) {
  $quiz = node_load(arg(1));
  quiz_question_goto($quiz, $form_state['values']['question_number'] - 1);
  $form_state['redirect'] = "node/{$quiz->nid}/take/" . $form_state['values']['question_number'];
}

/**
 * Menu access check for question feedback.
 */
function quiz_question_feedback_access($quiz, $question_number) {
  if ($question_number >= 1) {
    if (array_filter($quiz->review_options['question'])) {
      $question_index = $question_number;
      if (empty($_SESSION['quiz'][$quiz->nid]['result_id'])) {
        $result_id = $_SESSION['quiz']['temp']['result_id'];
      }
      else {
        $result_id = $_SESSION['quiz'][$quiz->nid]['result_id'];
      }
      $quiz_result = quiz_result_load($result_id);
      $qinfo = $quiz_result->layout[$question_index];

      if ($qra = quiz_result_answer_load($result_id, $qinfo['nid'], $qinfo['vid'])) {
        return TRUE;
      }
    }
  }
}

/**
 * Load a specific result answer.
 */
function quiz_result_answer_load($result_id, $nid, $vid) {
  $sql = 'SELECT * from {quiz_node_results_answers} WHERE result_id = :result_id AND question_nid = :nid AND question_vid = :vid';
  $result = db_query($sql, array(':result_id' => $result_id, ':nid' => $nid, ':vid' => $vid));
  if ($row = $result->fetch()) {
    return entity_load_single('quiz_result_answer', $row->result_answer_id);
  }
}

/**
 * Action to add questions to the current quiz.
 */
function quiz_add_question_to_quiz($question) {
  $quiz = node_load(arg(1));
  $quiz_questions = quiz_get_questions($quiz->nid, $quiz->vid);
  // Do not add a question if it's already been added (selected in an earlier checkbox)
  foreach ($quiz_questions as $q) {
    if ($question->vid == $q->vid) {
      return FALSE;
    }
  }
  // Otherwise let's add a relationship!
  $question->quiz_nid = $quiz->nid;
  $question->quiz_vid = $quiz->vid;
  _quiz_question_get_instance($question)->saveRelationships();
  quiz_update_max_score_properties(array($quiz->vid));
}

/**
 * Implements hook_action_info().
 */
function quiz_action_info() {
  $actions = array();

  $actions['quiz_add_question_to_quiz'] = array(
    'type' => 'node',
    'label' => t('Add questions to @quiz', array('@quiz' => QUIZ_NAME)),
    'configurable' => FALSE,
    'vbo_configurable' => FALSE,
  );

  return $actions;
}

/**
 * Workaround for menu_translate bug.
 */
function question_number_to_arg() {
  return 0;
}

/**
 * Can the quiz taker view the requested review?
 *
 * There's a workaround in here: @kludge
 *
 * When review for the question is enabled, and it is the last question,
 * technically it is the end of the quiz, and the "end of quiz" review settings
 * apply. So we check to make sure that we are in question taking and the
 * feedback is viewed within 5 seconds of completing the question/quiz.
 */
function quiz_feedback_can_review($option, $quiz_result) {
  $quiz = node_load($quiz_result->nid, $quiz_result->vid);

  // Check what context the result is in.
  if ($quiz_result->time_end && arg(2) != 'take') {
    // Quiz is over. Pull from the "at quiz end" settings.
    return !empty($quiz->review_options['end'][$option]);
  }

  if (!$quiz_result->time_end || $quiz_result->time_end >= REQUEST_TIME - 5) {
    // Quiz ongoing. Pull from the "after question" settings.
    return !empty($quiz->review_options['question'][$option]);
  }
}

/**
 * Get the feedback options for Quizzes.
 */
function quiz_get_feedback_options() {
  $feedback_options = array(
    'attempt' => "Attempt",
    'correct' => "Whether correct",
    'score' => "Score",
    'answer_feedback' => 'Answer feedback',
    'question_feedback' => 'Question feedback',
    'solution' => "Correct answer",
    'quiz_feedback' => t("@quiz feedback", array('@quiz' => QUIZ_NAME)),
  );

  drupal_alter('quiz_feedback_options', $feedback_options);

  return $feedback_options;
}

/**
 * Implements hook_quiz_result_load().
 *
 * Attach the layout which previously used to be stored on the result.
 */
function quiz_quiz_result_load($quiz_results) {
  foreach ($quiz_results as $quiz_result) {
    $layout = entity_load('quiz_result_answer', FALSE, array('result_id' => $quiz_result->result_id));
    foreach ($layout as $question) {
      // @kludge
      // This is bulky but now we have to manually find the type and parents of
      // the question. This is the only information that is not stored in the
      // quiz attempt. We reference back to the node relationships for this
      // current version to get the hieararchy.
      $sql = "SELECT n.type, qnr_id, qnr_pid FROM {quiz_node_results} qr
        INNER JOIN {quiz_node_relationship} qnr on (qr.nid = qnr.parent_nid and qr.vid = qnr.parent_vid)
        INNER JOIN {node} n ON (qnr.child_nid = n.nid)
        WHERE qr.result_id = :result_id and n.nid = :nid";
      $result = db_query($sql, array(':result_id' => $quiz_result->result_id, ':nid' => $question->question_nid));
      $extra = $result->fetch();

      $quiz_result->layout[$question->number] = array(
        'display_number' => $question->number,
        'nid' => $question->question_nid,
        'vid' => $question->question_vid,
        'number' => $question->number,
        'type' => $extra->type,
        'qnr_id' => $extra->qnr_id,
        'qnr_pid' => $extra->qnr_pid,
      );
    }
  }
}

/**
 * Check if the question has already been answered in the requested attempt.
 *
 * @return boolean
 *   TRUE if the question has been answered in the attempt.
 */
function quiz_result_is_question_answered($quiz_result, $question) {
  $qra = quiz_result_answer_load($quiz_result->result_id, $question->nid, $question->vid);
  return !empty($qra->answer_timestamp);
}

/**
 * Handles the start and end times in a node form submission.
 *
 * @param $node The submitted node with form data.
 * @param $date The name of the date ('quiz_open' or 'quiz_close') to translate.
 */
function quiz_translate_form_date(&$node, $date) {
  $human = $node->$date;
  if (strtotime($human) !== FALSE) {
    $timestamp = strtotime($human);
    $node->$date = $timestamp;
  }
}
